<Gratin type="node">
 <int name="majorVersion" val="0"/>
 <int name="minorVersion" val="3"/>
 <string name="coreHandleStringId" val="2DValueNoiseID"/>
 <uint name="coreHandleVersion" val="1"/>
 <string name="nodeStringId-0" val="3DGaborNoiseID"/>
 <uint name="nodeVersion-0" val="1"/>
 <string name="nodeName-0" val="3DGaborNoise"/>
 <string name="nodePath-0" val="Texture/"/>
 <string name="nodeDesc-0" val="Solid Gabor Noise"/>
 <string name="nodeHelp-0" val="Based on the example code for the article of Lagae, A. and Drettakis, G. 2011. Filtering Solid Gabor Noise. ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2011) 30, 4. Copyright (C) 2011 Ares Lagae (ares.lagae@cs.kuleuven.be) and George Drettakis (george.drettakis@inria.fr). This work is licensed under a non-commercial license."/>
 <uint name="nodeId-0" val="0"/>
 <uint name="nodeGraphId-0" val="0"/>
 <vector2f name="nodePos-0">
  <float name="0" val="0"/>
  <float name="1" val="0"/>
 </vector2f>
 <int name="nodeInputNameSize-0" val="0"/>
 <int name="nodeOutputNameSize-0" val="1"/>
 <string name="nodeOutputName-0-0" val="proceduralTex"/>
 <bool name="nodeHasWidget-0" val="1"/>
 <IOData name="node-0">
  <string name="genericGlslVersion" val="410"/>
  <string name="genericNodeName" val="3DGaborNoise"/>
  <bool name="genericUseVertex" val="0"/>
  <bool name="genericUseTesselation" val="0"/>
  <bool name="genericUseGeometry" val="0"/>
  <bool name="genericUseFragment" val="1"/>
  <int name="genericOutFilter" val="9729"/>
  <int name="genericOutWrap" val="33071"/>
  <bool name="genericUseDepthTest" val="0"/>
  <bool name="genericUseBlending" val="0"/>
  <uint name="genericDepthFunc" val="513"/>
  <uint name="genericBlendSrc" val="1"/>
  <uint name="genericBlendDst" val="0"/>
  <vector4f name="genericBackground">
   <float name="0" val="0"/>
   <float name="1" val="0"/>
   <float name="2" val="0"/>
   <float name="3" val="0"/>
  </vector4f>
  <string name="genericVertHead" val="#version 410&#xa;&#xa;layout(location = 0) in vec2 vertex;&#xa;layout(location = 1) in vec2 coord;&#xa;uniform float frequency;&#xa;uniform float bandwidth;&#xa;uniform float truncate;&#xa;uniform float impulses;&#xa;uniform float ZCoord;&#xa;uniform float scaling;&#xa;uniform int type;&#xa;uniform int seed;&#xa;uniform vec3 orientation;&#xa;"/>
  <string name="genericVertBody" val="out vec2 texcoord;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = vec4(vertex,0,1);&#xa;&#x9;texcoord    = coord;&#xa;}&#xa;"/>
  <string name="genericFragHead" val="#version 410&#xa;&#xa;layout(location = 0) out vec4 proceduralTex;&#xa;uniform float frequency;&#xa;uniform float bandwidth;&#xa;uniform float truncate;&#xa;uniform float impulses;&#xa;uniform float ZCoord;&#xa;uniform float scaling;&#xa;uniform int type;&#xa;uniform int seed;&#xa;uniform vec3 orientation;&#xa;"/>
  <string name="genericFragBody" val="in vec2 texcoord;&#xa;&#xa;/*&#xa; * Filtering Solid Gabor Noise&#xa; * &#xa; * Example code for the article&#xa; * Lagae, A. and Drettakis, G. 2011. Filtering Solid Gabor Noise.&#xa; * ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2011) 30, 4.&#xa; * &#xa; * Copyright (C) 2011 Ares Lagae (ares.lagae@cs.kuleuven.be) and George&#xa; * Drettakis (george.drettakis@inria.fr)&#xa; * &#xa; * This work is licensed under a non-commercial license (see LICENSE.txt).&#xa; *&#xa; * Permissions beyond the scope of this license are be available from the&#xa; * authors.&#xa; *&#xa; * If you use this software, you must site the article.&#xa; */&#xa;&#xa;// -----------------------------------------------------------------------------&#xa;&#xa;const float pi = 3.14159265358979323846;&#xa;&#xa;// -----------------------------------------------------------------------------&#xa;&#xa;struct noise_prng&#xa;{&#xa;  uint x_;&#xa;};&#xa;&#xa;void noise_prng_srand(inout noise_prng this_, const in uint s)&#xa;{&#xa;  this_.x_ = s;&#xa;}&#xa;&#xa;uint noise_prng_rand(inout noise_prng this_)&#xa;{&#xa;  return this_.x_ *= 3039177861u;&#xa;}&#xa;      &#xa;float noise_prng_uniform_0_1(inout noise_prng this_)&#xa;{&#xa;  return float(noise_prng_rand(this_)) / float(4294967295u);&#xa;}&#xa;&#xa;float noise_prng_uniform(inout noise_prng this_, const in float min_, const in float max_)&#xa;{&#xa;  return min_ + (noise_prng_uniform_0_1(this_) * (max_ - min_));&#xa;}&#xa;&#xa;uint noise_prng_poisson(inout noise_prng this_, const in float mean)&#xa;{&#xa;  return uint(mean);&#xa;}&#xa;&#xa;// -----------------------------------------------------------------------------&#xa;&#xa;float noise_gabor_kernel_2d(const in float w, const in vec2 f, const in float phi, const in float a, const in vec2 x)&#xa;{&#xa;  // see Eqn. 1&#xa;  float g = exp(-pi * (a * a) * dot(x, x));&#xa;  float h = cos((2.0 * pi * dot(f, x)) + phi);&#xa;  return w * g * h;&#xa;}&#xa;&#xa;float noise_gabor_kernel_3d(const in float w, const in vec3 f, const in float phi, const in float a, const in vec3 x)&#xa;{&#xa;  // see Eqn. 1&#xa;  float g = exp(-pi * (a * a) * dot(x, x));&#xa;  float h = cos((2.0 * pi * dot(f, x)) + phi);&#xa;  return w * g * h;&#xa;}&#xa;&#xa;void noise_transform_gabor_kernel_3d(const in mat3 m, const in float w, const in float a, const in vec3 omega, const in float phi, out float w_t, out float a_t, out vec3 omega_t, out float phi_t)&#xa;{&#xa;  // see Sec. 5 (Transforming the Phase-Augmented Gabor kernel)&#xa;  w_t = w;&#xa;  a_t = a;&#xa;  omega_t = m * omega;&#xa;  phi_t = phi;&#xa;}&#xa;&#xa;void noise_slice_gabor_kernel_3d(float d, const in float w, const in float a, const in vec3 omega, const in float phi, out float w_s, out float a_s, out vec2 omega_s, out float phi_s)&#xa;{&#xa;  // see Eqn. 6&#xa;  w_s = w * exp(-(pi * (a * a) * (d * d)));&#xa;  a_s = a;&#xa;  omega_s = omega.xy;&#xa;  phi_s = phi - (2 * pi * d * omega.z);  &#xa;}&#xa;&#xa;void noise_filter_gabor_kernel_2d(const in mat2 filterMat, const in float w, const in float a, const in vec2 omega, const in float phi, out float w_f, out float a_f, out vec2 omega_f, out float phi_f)&#xa;{&#xa;  // see Eqn. 10&#xa;  mat2 Sigma_f = filterMat;&#xa;  float c_G = w;&#xa;  vec2 mu_G = omega;&#xa;  mat2 Sigma_G = ((a * a) / (2.0 * pi)) * mat2(1.0);&#xa;  float c_F = 1.0 / (2.0 * pi * sqrt(determinant(Sigma_f)));&#xa;  mat2 Sigma_F = (1.0 / (4.0 * (pi * pi))) * inverse(Sigma_f);&#xa;  mat2 Sigma_G_Sigma_F = Sigma_G + Sigma_F;&#xa;  float c_GF = c_F * c_G * ((1.0 / (2.0 * pi * sqrt(determinant(Sigma_G_Sigma_F)))) * exp(-((1.0 / 2.0) * (dot(mu_G * inverse(Sigma_G_Sigma_F), mu_G)))));&#xa;  mat2 Sigma_GF = inverse(inverse(Sigma_G) + inverse(Sigma_F));&#xa;  vec2 mu_GF = Sigma_GF * inverse(Sigma_G) * mu_G;&#xa;  w_f = c_GF;&#xa;  a_f = sqrt(2.0 * pi * sqrt(determinant(Sigma_GF)));&#xa;  omega_f = mu_GF;&#xa;  phi_f = phi;&#xa;}&#xa;&#xa;// -----------------------------------------------------------------------------&#xa;&#xa;struct noise&#xa;{&#xa;  float lambda_;&#xa;  float r_;&#xa;  uint seed_;&#xa;  vec3 omega_;&#xa;  float a_;&#xa;  int type_;&#xa;  bool filter_;&#xa;};&#xa;&#xa;void noise_constructor(out noise this_, const in float lambda, const in float r, const in uint seed, const in vec3 omega, const in float a, const in int type, const in bool filtered)&#xa;{&#xa;  this_.lambda_ = lambda;&#xa;  this_.r_ = r;&#xa;  this_.seed_ = seed;&#xa;  this_.omega_ = omega;&#xa;  this_.a_ = a;&#xa;  this_.type_ = type;&#xa;  this_.filter_ = filtered;&#xa;}&#xa;&#xa;void noise_sample(const in noise this_, inout noise_prng prng, out float w, out vec3 omega, out float phi, out float a)&#xa;{&#xa;  // see Sec. 3.3 (Different Kinds of Solid Random-Phase Gabor Noise)&#xa;  w = 1.0;&#xa;  if (this_.type_ == 0) {&#xa;    // anisotropic&#xa;    omega = this_.omega_;&#xa;  }&#xa;  else if (this_.type_ == 1) {&#xa;     // isotropic&#xa;    float f = length(this_.omega_);&#xa;    float omega_r = f;&#xa;    float omega_t = noise_prng_uniform(prng, 0.0, 2.0 * pi);&#xa;    float omega_p = acos(noise_prng_uniform(prng, -1.0, +1.0));&#xa;    omega = omega_r * vec3(cos(omega_t) * sin(omega_p), sin(omega_t) * sin(omega_p), cos(omega_p));&#xa;  }&#xa;  else {&#xa;    // hybrid&#xa;    float f = length(this_.omega_);&#xa;    float omega_r = f;&#xa;    float omega_t = noise_prng_uniform(prng, 0.0, 2.0 * pi);&#xa;    omega = omega_r * vec3(cos(omega_t), sin(omega_t), 0.0);&#xa;  }&#xa;  phi = noise_prng_uniform(prng, 0.0, 2.0 * pi);&#xa;  a = this_.a_;&#xa;}&#xa;&#xa;float noise_cell(const in noise this_, const in ivec3 c, const in vec3 x_c, const in vec3 n, const in vec3 t, const in vec3 b, const in mat2 filterMat)&#xa;{&#xa;  const uint period = 256u;&#xa;  uint seed = (((((uint(c[2]) % period) * period) + (uint(c[1]) % period)) * period) + (uint(c[0]) % period)) + this_.seed_;&#xa;  if (seed == 0u) seed = 1u;&#xa;  noise_prng prng;&#xa;  noise_prng_srand(prng, seed);&#xa;  uint number_of_impulses = noise_prng_poisson(prng, this_.lambda_ * this_.r_ * this_.r_ * this_.r_);&#xa;  float sum = 0.0;&#xa;  for (uint i = 0u; i &lt; number_of_impulses; ++i) {&#xa;    vec3 x_i_c = vec3(noise_prng_uniform_0_1(prng), noise_prng_uniform_0_1(prng), noise_prng_uniform_0_1(prng));&#xa;    vec3 x_k_i = this_.r_ * (x_c - x_i_c);&#xa;    float w_i; vec3 omega_i; float phi_i, a_i;&#xa;    noise_sample(this_, prng, w_i, omega_i, phi_i, a_i);&#xa;    if (dot(x_k_i, x_k_i) &lt; (this_.r_ * this_.r_)) {&#xa;      if (this_.filter_ == false) {&#xa;        sum += noise_gabor_kernel_3d(w_i, omega_i, phi_i, a_i, x_k_i);&#xa;      }&#xa;      else {&#xa;        float d_i = -dot(n, x_k_i);&#xa;        mat3 m = transpose(mat3(t, b, n));&#xa;        float w_i_t; float a_i_t; vec3 omega_i_t; float phi_i_t;&#xa;        noise_transform_gabor_kernel_3d(m, w_i, a_i, omega_i, phi_i, w_i_t, a_i_t, omega_i_t, phi_i_t);        &#xa;        float w_i_t_s; float a_i_t_s; vec2 omega_i_t_s; float phi_i_t_s;&#xa;        noise_slice_gabor_kernel_3d(d_i, 1.0, a_i_t, omega_i_t, phi_i_t, w_i_t_s, a_i_t_s, omega_i_t_s, phi_i_t_s);&#xa;        float w_i_t_s_f; float a_i_t_s_f; vec2 omega_i_t_s_f; float phi_i_t_s_f;&#xa;        noise_filter_gabor_kernel_2d(filterMat, w_i_t_s, a_i_t_s, omega_i_t_s, phi_i_t_s, w_i_t_s_f, a_i_t_s_f, omega_i_t_s_f, phi_i_t_s_f);&#xa;        sum += noise_gabor_kernel_2d(w_i_t_s_f, omega_i_t_s_f, phi_i_t_s_f, a_i_t_s_f, (m * x_k_i).xy);&#xa;      }&#xa;    }&#xa;  }&#xa;  return sum;&#xa;}&#xa;&#xa;float noise_grid(const in noise this_, const in vec3 x_g, const in vec3 n, const in vec3 t, const in vec3 b, const in mat2 filterMat)&#xa;{&#xa;  vec3 int_x_g = floor(x_g);&#xa;  ivec3 c = ivec3(int_x_g);&#xa;  vec3 x_c = x_g - int_x_g;&#xa;  float sum = 0.0;&#xa;  ivec3 i;&#xa;  for (i[2] = -1; i[2] &lt;= +1; ++i[2]) {&#xa;    for (i[1] = -1; i[1] &lt;= +1; ++i[1]) {&#xa;      for (i[0] = -1; i[0] &lt;= +1; ++i[0]) {&#xa;        ivec3 c_i = c + i;&#xa;        vec3 x_c_i = x_c - i;&#xa;        sum += noise_cell(this_, c_i, x_c_i, n, t, b, filterMat);&#xa;      }&#xa;    }&#xa;  }&#xa;  return sum / sqrt(this_.lambda_);&#xa;}&#xa;&#xa;float noise_evaluate(const in noise this_, const in vec3 x, const in vec3 n, const in vec3 t, const in vec3 b, const in mat2 filterMat)&#xa;{&#xa;  vec3 x_g = x / this_.r_;&#xa;  return noise_grid(this_, x_g, n, t, b, filterMat);&#xa;}&#xa;&#xa;float noise_variance(const in noise this_)&#xa;{&#xa;  return (1.0 / (4.0 * sqrt(2.0) * (this_.a_ * this_.a_ * this_.a_)));&#xa;}&#xa;&#xa;// -----------------------------------------------------------------------------    &#xa;&#xa;vec3 perp(in vec3 v)&#xa;{&#xa;  vec3 abs_v = abs(v);&#xa;  if ((abs_v.x &lt;= abs_v.y) &amp;&amp; (abs_v.x &lt;= abs_v.z)) {&#xa;    return vec3(0, -v.z, v.y);&#xa;  }&#xa;  else if (abs_v.y &lt;= abs_v.z) {&#xa;    return vec3(-v.z, 0, v.x);&#xa;  }&#xa;  else {&#xa;    return vec3(-v.y, v.x, 0);&#xa;  }&#xa;}&#xa;&#xa;void main()&#xa;{  &#xa;  noise n;&#xa;  vec3 omega = frequency * orientation;&#xa;  float a = (frequency * ((pow(2.0f, bandwidth) - 1.0f) / (pow(2.0f, bandwidth) + 1.0f))) * sqrt(pi / log(2.0f));&#xa;  float r = sqrt(-log(truncate) / pi) / a;&#xa;  float lambda = impulses / ((4.0f / 3.0f) * pi * (r * r * r));&#xa;  noise_constructor(n, lambda, r, seed, omega, a, type, false);&#xa;  vec3 n_tex = vec3(0,0,1);&#xa;&#xa;  vec3 x_tex = scaling*vec3(texcoord,ZCoord);&#xa;&#xa;  // see Sec. 5 (Continuity of the Local Coordinate System)&#xa;  vec3 t_tex = vec3(1,0,0);&#xa;  vec3 b_tex = cross(n_tex, t_tex);&#xa;&#xa;  // see Sec. 5 (Definition of the Filtering Gaussian)&#xa;  mat2 M_scr_tan = mat2(transpose(mat3(t_tex, b_tex, n_tex)) * mat2x3(dFdx(x_tex), dFdy(x_tex)));&#xa;  float sigma_f_scr = 0.5;&#xa;  mat2 Sigma_f_scr = (sigma_f_scr * sigma_f_scr) * mat2(1.0);&#xa;  mat2 Sigma_f_tan = M_scr_tan * Sigma_f_scr * transpose(M_scr_tan);&#xa;&#xa;  float noise_e = noise_evaluate(n, x_tex, n_tex, t_tex, b_tex, Sigma_f_tan);&#xa;&#xa;  float scale = 0.5 / (3.0 * sqrt(noise_variance(n)));&#xa;  float bias = 0.5;&#xa;  float color = bias + (scale * noise_e);&#xa;  proceduralTex =  vec4(vec3(color),1.);&#x9;&#xa;}"/>
  <string name="genericTessCHead" val="#version 410&#xa;&#xa;layout(vertices = 4) out;&#xa;uniform float frequency;&#xa;uniform float bandwidth;&#xa;uniform float truncate;&#xa;uniform float impulses;&#xa;uniform float ZCoord;&#xa;uniform float scaling;&#xa;uniform int type;&#xa;uniform int seed;&#xa;uniform vec3 orientation;&#xa;"/>
  <string name="genericTessCBody" val="void main(void) {&#xa;&#x9;gl_TessLevelOuter[0] = 1;&#xa;&#x9;gl_TessLevelOuter[1] = 1;&#xa;&#x9;gl_TessLevelOuter[2] = 1;&#xa;&#x9;gl_TessLevelOuter[3] = 1;&#xa;&#x9;gl_TessLevelInner[0] = 1;&#xa;&#x9;gl_TessLevelInner[1] = 1;&#xa;&#x9;gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;&#xa;}&#xa;"/>
  <string name="genericTessEHead" val="#version 410&#xa;&#xa;uniform float frequency;&#xa;uniform float bandwidth;&#xa;uniform float truncate;&#xa;uniform float impulses;&#xa;uniform float ZCoord;&#xa;uniform float scaling;&#xa;uniform int type;&#xa;uniform int seed;&#xa;uniform vec3 orientation;&#xa;"/>
  <string name="genericTessEBody" val="layout(quads,equal_spacing) in;&#xa;&#xa;void main() {&#xa;&#x9;vec4 p1 = mix(gl_in[0].gl_Position,gl_in[1].gl_Position,gl_TessCoord.x);&#xa;&#x9;vec4 p2 = mix(gl_in[3].gl_Position,gl_in[2].gl_Position,gl_TessCoord.x);&#xa;&#x9;gl_Position = mix(p1,p2,gl_TessCoord.y);&#xa;}&#xa;"/>
  <string name="genericGeomHead" val="#version 410&#xa;&#xa;layout(triangles) in;&#xa;uniform float frequency;&#xa;uniform float bandwidth;&#xa;uniform float truncate;&#xa;uniform float impulses;&#xa;uniform float ZCoord;&#xa;uniform float scaling;&#xa;uniform int type;&#xa;uniform int seed;&#xa;uniform vec3 orientation;&#xa;"/>
  <string name="genericGeomBody" val="layout(triangle_strip, max_vertices = 3) out;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = gl_in[0].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[1].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[2].gl_Position; EmitVertex();&#xa;&#x9;EndPrimitive();&#xa;}"/>
  <vector2f name="genericTSize">
   <float name="0" val="0"/>
   <float name="1" val="0"/>
  </vector2f>
  <vector2f name="genericTOffset">
   <float name="0" val="512"/>
   <float name="1" val="512"/>
  </vector2f>
  <bool name="genericNeedMouse" val="0"/>
  <bool name="genericNeedKeyboard" val="0"/>
  <uint name="genericNbWidgets" val="9"/>
  <int name="genericWidgetType-0" val="1"/>
  <int name="genericWidgetView-0" val="1"/>
  <string name="genericWidgetName-0" val="type"/>
  <bool name="genericWidgetKeyframed-0" val="0"/>
  <int name="genericWidgetType-1" val="0"/>
  <int name="genericWidgetView-1" val="1"/>
  <string name="genericWidgetName-1" val="frequency"/>
  <bool name="genericWidgetKeyframed-1" val="1"/>
  <int name="genericWidgetType-2" val="4"/>
  <int name="genericWidgetView-2" val="1"/>
  <string name="genericWidgetName-2" val="orientation"/>
  <bool name="genericWidgetKeyframed-2" val="0"/>
  <int name="genericWidgetType-3" val="0"/>
  <int name="genericWidgetView-3" val="1"/>
  <string name="genericWidgetName-3" val="bandwidth"/>
  <bool name="genericWidgetKeyframed-3" val="1"/>
  <int name="genericWidgetType-4" val="0"/>
  <int name="genericWidgetView-4" val="1"/>
  <string name="genericWidgetName-4" val="truncate"/>
  <bool name="genericWidgetKeyframed-4" val="1"/>
  <int name="genericWidgetType-5" val="0"/>
  <int name="genericWidgetView-5" val="1"/>
  <string name="genericWidgetName-5" val="impulses"/>
  <bool name="genericWidgetKeyframed-5" val="0"/>
  <int name="genericWidgetType-6" val="1"/>
  <int name="genericWidgetView-6" val="1"/>
  <string name="genericWidgetName-6" val="seed"/>
  <bool name="genericWidgetKeyframed-6" val="0"/>
  <int name="genericWidgetType-7" val="0"/>
  <int name="genericWidgetView-7" val="1"/>
  <string name="genericWidgetName-7" val="ZCoord"/>
  <bool name="genericWidgetKeyframed-7" val="1"/>
  <int name="genericWidgetType-8" val="0"/>
  <int name="genericWidgetView-8" val="1"/>
  <string name="genericWidgetName-8" val="scaling"/>
  <bool name="genericWidgetKeyframed-8" val="0"/>
 </IOData>
 <IOData name="nodeWidget-0">
  <uint name="nbChildren" val="9"/>
  <IOData name="childWidget-0">
   <bool name="intAttribKeyframed" val="0"/>
   <int name="intAttribMinVal" val="0"/>
   <int name="intAttribMaxVal" val="2"/>
   <IOData name="intAttribCurve">
    <int name="currentVal" val="0"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="0"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-1">
   <bool name="floatAttribKeyframed" val="1"/>
   <float name="floatAttribMinVal" val="0"/>
   <float name="floatAttribMaxVal" val="0.5"/>
   <IOData name="floatAttribCurve">
    <float name="currentVal" val="0.031"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="0.031"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-2">
   <bool name="vector3fAttribKeyframed" val="0"/>
   <vector3f name="vector3fAttribMinVal">
    <float name="0" val="0"/>
    <float name="1" val="0"/>
    <float name="2" val="0"/>
   </vector3f>
   <vector3f name="vector3fAttribMaxVal">
    <float name="0" val="1"/>
    <float name="1" val="1"/>
    <float name="2" val="1"/>
   </vector3f>
   <IOData name="vector3fAttribCurve">
    <vector3f name="currentVal">
     <float name="0" val="1"/>
     <float name="1" val="1"/>
     <float name="2" val="1"/>
    </vector3f>
    <uint name="nbCurves" val="3"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="1"/>
      </vector2f>
     </IOData>
    </IOData>
    <IOData name="curve-1">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="1"/>
      </vector2f>
     </IOData>
    </IOData>
    <IOData name="curve-2">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="1"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-3">
   <bool name="floatAttribKeyframed" val="1"/>
   <float name="floatAttribMinVal" val="0"/>
   <float name="floatAttribMaxVal" val="4"/>
   <IOData name="floatAttribCurve">
    <float name="currentVal" val="1"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="1"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-4">
   <bool name="floatAttribKeyframed" val="1"/>
   <float name="floatAttribMinVal" val="0"/>
   <float name="floatAttribMaxVal" val="0.1"/>
   <IOData name="floatAttribCurve">
    <float name="currentVal" val="0.0199"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="0.0199"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-5">
   <bool name="floatAttribKeyframed" val="0"/>
   <float name="floatAttribMinVal" val="1"/>
   <float name="floatAttribMaxVal" val="256"/>
   <IOData name="floatAttribCurve">
    <float name="currentVal" val="31.855"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="31.855"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-6">
   <bool name="intAttribKeyframed" val="0"/>
   <int name="intAttribMinVal" val="0"/>
   <int name="intAttribMaxVal" val="10000"/>
   <IOData name="intAttribCurve">
    <int name="currentVal" val="1234"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="1234"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-7">
   <bool name="floatAttribKeyframed" val="1"/>
   <float name="floatAttribMinVal" val="0"/>
   <float name="floatAttribMaxVal" val="1"/>
   <IOData name="floatAttribCurve">
    <float name="currentVal" val="0"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="0"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
  <IOData name="childWidget-8">
   <bool name="floatAttribKeyframed" val="0"/>
   <float name="floatAttribMinVal" val="1"/>
   <float name="floatAttribMaxVal" val="2048"/>
   <IOData name="floatAttribCurve">
    <float name="currentVal" val="512"/>
    <uint name="nbCurves" val="1"/>
    <IOData name="curve-0">
     <int name="interpType" val="0"/>
     <int name="leftType" val="0"/>
     <int name="rightType" val="0"/>
     <IOData name="interpolator">
      <uint name="nbPoints" val="1"/>
      <uint name="nbTangents" val="0"/>
      <vector2f name="controlPoint-0">
       <float name="0" val="0"/>
       <float name="1" val="512"/>
      </vector2f>
     </IOData>
    </IOData>
   </IOData>
   <uint name="nbChildren" val="0"/>
  </IOData>
 </IOData>
 <vector2f name="nodeOutputPos-0-0">
  <float name="0" val="56.32"/>
  <float name="1" val="28.16"/>
 </vector2f>
</Gratin>
