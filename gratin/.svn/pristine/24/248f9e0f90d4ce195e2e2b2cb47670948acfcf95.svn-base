# the project 
project(GRATIN)

# compiler options 
set(CMAKE_BUILD_TYPE CMAKE_CXX_FLAGS_RELEASE)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O3 -pedantic")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -W -Wno-long-long -Woverloaded-virtual -Wextra -Wno-variadic-macros")

# path to gratin folder
set(GRATIN_PATH ${CMAKE_CURRENT_LIST_DIR}/..)

# lib and exe names
string(TOLOWER ${PROJECT_NAME} PROJECT_NAME_LOWER)
set(GRATIN_LIB ${PROJECT_NAME_LOWER}-src)
set(GRATIN_EXE ${PROJECT_NAME_LOWER})

# lib and exe dirs 
set(GRATIN_LIB_DIR ${GRATIN_PATH}/lib)
set(GRATIN_EXE_DIR ${GRATIN_PATH})

# output display options 
set(CMAKE_COLOR_MAKEFILE ON)
set(CMAKE_VERBOSE_MAKEFILE FALSE)
set(QT_QMAKE_EXECUTABLE /usr/bin/qmake-qt4)



# find all external lib used in gratin
macro(find_default_packages)
	# modules path
	set(CMAKE_MODULE_PATH ${GRATIN_PATH}/cmake)
	
	# needed packages 
	find_package(Eigen3 REQUIRED)
	find_package(Qt4 COMPONENTS QtCore QtGui QtOpenGL QtXml REQUIRED)
	find_package(OpenGL REQUIRED)
	find_package(GLEW REQUIRED)
	find_package(OpenEXR QUIET)
endmacro(find_default_packages)




# add paths to gratin and external libraries
macro(add_default_paths)
	# Qt files 
	include(${QT_USE_FILE})
	
	# Qt modules 
	set(QT_USE_QTOPENGL TRUE)
	set(QT_USE_QTXML TRUE)

	# gratin/cmake dirs
	include_directories(${GRATIN_PATH}/src)
	include_directories(${CMAKE_BINARY_DIR})

	# default external incude dirs 
	include_directories(${EIGEN3_INCLUDE_DIR})
	include_directories(${QT_INCLUDE_DIR})
	include_directories(${OPENGL_INCLUDE_DIR})
	include_directories(${GLEW_INCLUDE_DIR})

	# gratin lib dir
	link_directories(${GRATIN_LIB_DIR})

	# default external lib dirs
	link_directories(${QT_LIB_DIR})
	link_directories(${OPENGL_LIB_DIR})
	link_directories(${GLEW_LIB_DIR})

	# optional openexr package 
	if(OPENEXR_FOUND)
		add_definitions(-DEXR_SUPPORT) 
		include_directories(${OPENEXR_INCLUDE_PATHS})
	endif(OPENEXR_FOUND)
endmacro(add_default_paths)




# find in the input list, files that contain the Q_OBJECT keyword 
macro(find_qt_object_files input_headers output_headers)
  set(out_files)
  foreach(header ${input_headers})
    file(STRINGS "${header}" lines REGEX "Q_OBJECT")
    if(lines)
        list(APPEND out_files "${header}")
    endif()
  endforeach()

  set(${output_headers} ${out_files})
endmacro(find_qt_object_files)




# link the lib or exe to the external libraries
macro(link_to_default_libs target)
	target_link_libraries(${target} ${QT_LIBRARIES} ${GLEW_LIBRARIES} ${OPENGL_LIBRARIES}) 
	
	if(OPENEXR_FOUND)
		target_link_libraries(${target} ${OPENEXR_LIBRARIES})
	endif(OPENEXR_FOUND)
endmacro(link_to_default_libs)




# link to gratin library
macro(link_to_gratin_lib target)
	target_link_libraries(${target} ${GRATIN_LIB}) 
endmacro(link_to_gratin_lib)




# convenient macro for creating a basic node library (from source files)
# links to libraries other than the default ones should be done manually  
macro(create_node_lib_from_filenames node_name header_files source_files resource_files ui_files output_path)
	# build shared libs
	set(BUILD_SHARED_LIBS ON)

	# copy files 
	set(NODE_ALL_HEADERS "${header_files}")
	set(NODE_SOURCES "${source_files}")
	set(NODE_RESOURCES "${resource_files}")
	set(NODE_UIS "${ui_files}")

	# find and convert qt related files 
	find_qt_object_files("${NODE_ALL_HEADERS}" NODE_HEADERS)
	qt4_wrap_cpp(NODE_HEADERS_MOC ${NODE_HEADERS})
	qt4_wrap_ui(NODE_UIS_SRC ${NODE_UIS})
	qt4_add_resources(NODE_RESOURCES_RCC ${NODE_RESOURCES})

	# output library directory
	set(LIBRARY_OUTPUT_PATH ${output_path})

	# create the library (using lib-name and all associated source-files)
	add_library(${node_name} ${NODE_SOURCES} ${NODE_HEADERS_MOC} ${NODE_UIS_SRC} ${NODE_RESOURCES_RCC}) 

	# link with default libraries and gratin
	link_to_default_libs(${node_name})
	link_to_gratin_lib(${node_name})
endmacro(create_node_lib_from_filenames)




# convenient macro for creating a basic node library (from source paths)
# links to libraries other than the default ones should be done manually  
macro(create_node_lib_from_single_path node_name sources_path output_path)
	# get all header, source and resource files 
	file(GLOB NODE_ALL_HEADERS ${sources_path}/*.h ${sources_path}/*.hpp)
	file(GLOB NODE_SOURCES ${sources_path}/*.cpp ${sources_path}/*.cxx)
	file(GLOB NODE_RESOURCES ${sources_path}/*.qrc)
	file(GLOB NODE_UIS ${sources_path}/*.ui)

	# create the node lib from filenames
	create_node_lib_from_filenames(${node_name} "${NODE_ALL_HEADERS}" "${NODE_SOURCES}" "${NODE_RESOURCES}" "${NODE_UIS}" ${output_path})
endmacro(create_node_lib_from_single_path)





# convenient maco that adds all the subdirectories containing a file CMakeLists.txt
macro(add_sub_dirs input_path)
	set(out_dirs)
	file(GLOB in_dirs ${input_path}/*)
	foreach(in_dir_name ${in_dirs})
		if(EXISTS "${in_dir_name}/CMakeLists.txt")
			  message("-- Found plugin directory: ${in_dir_name}")
			  add_subdirectory(${in_dir_name})
		endif()
	endforeach(in_dir_name)
endmacro(add_sub_dirs)
