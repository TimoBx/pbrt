<Gratin type="node">
 <int val="0" name="majorVersion"/>
 <int val="2" name="minorVersion"/>
 <string val="_GRATIN_GROUPED_NODES_ID_" name="coreHandleStringId"/>
 <uint val="1" name="coreHandleVersion"/>
 <string val="_GRATIN_GROUPED_NODES_ID_" name="nodeStringId-0"/>
 <uint val="1" name="nodeVersion-0"/>
 <string val="SMAA" name="nodeName-0"/>
 <string val="rendering/" name="nodePath-0"/>
 <string val="post processing antialiasing" name="nodeDesc-0"/>
 <string val="This group is a image based post processing antialiasing.&#xa;The full name is : &quot;SMAA : Enhanced Subpixel Morphological Antialiasing&quot;.&#xa;&#xa;It was made by Jorge Jimenez, Jose I. Echevarria, Tiago Sousa and Diego Gutierrez.&#xa;&#xa;The explanation is available at http://www.iryoku.com/smaa/&#xa;Most of this code come from https://github.com/iryoku/smaa/" name="nodeHelp-0"/>
 <uint val="0" name="nodeId-0"/>
 <uint val="0" name="nodeGraphId-0"/>
 <vector2f name="nodePos-0">
  <float val="409.162" name="0"/>
  <float val="1864.9" name="1"/>
 </vector2f>
 <int val="1" name="nodeInputNameSize-0"/>
 <int val="1" name="nodeOutputNameSize-0"/>
 <string val="inBuffer0" name="nodeInputName-0-0"/>
 <string val="antialiasing" name="nodeOutputName-0-0"/>
 <bool val="1" name="nodeHasWidget-0"/>
 <IOData name="node-0">
  <uint val="6" name="nbNodes"/>
  <string val="imgGenericId" name="nodeStringId-0"/>
  <uint val="1" name="nodeVersion-0"/>
  <string val="multiplicator" name="nodeName-0"/>
  <string val="generic/" name="nodePath-0"/>
  <string val="Generic node for image processing" name="nodeDesc-0"/>
  <string val="This node was designed to create custom shaders&#xa;The settings widget allows to modify input, output parameters&#xa;as well as the output image sizes.&#xa;&#xa;WARNING1: you will be able to modify the number of inputs/outputs&#xa;only if the node is entirely disconnected.&#xa;WARNING2: input/output names will not be modified if a custom node is created&#xa;from this node because these names should be edited directly in the setting widget&#xa;WARNING3: modifying the settings of a node will remove all previously&#xa;defined keyframes&#xa;&#xa;* Special data allows to modify the output image (using a multiple of&#xa;the input size, plus an offset vector&#xa;Check use mouse/keyboard if you want to interact with the mouse&#xa;&#xa;* Input data allows to add/remove/displace input data (only if disconnected)&#xa;&#xa;* Output data allows to add/remove/displace output data (only if disconnected)&#xa;&#xa;* Param data allows to add/remove parameters that will automatically be &#xa;included in your shader.&#xa;For each of them you may choose a proper name, type, and min/max/default values.&#xa;Check keyframes if you want your parameter to be accessible&#xa; through the animation widget&#xa;&#xa;In the node interface itself:&#xa;Source tab contains the head and body of your GLSL source (only the body is editable)&#xa;Params tab contains the defined widgets according to your setting choices&#xa;Log tab contains compilation errors&#xa;&#xa;Once your settings and source completed, click on apply to see the result&#xa;" name="nodeHelp-0"/>
  <uint val="0" name="nodeId-0"/>
  <uint val="0" name="nodeGraphId-0"/>
  <vector2f name="nodePos-0">
   <float val="-2246.42" name="0"/>
   <float val="-366.779" name="1"/>
  </vector2f>
  <int val="1" name="nodeInputNameSize-0"/>
  <int val="2" name="nodeOutputNameSize-0"/>
  <string val="inBuffer0" name="nodeInputName-0-0"/>
  <string val="outBuffer0" name="nodeOutputName-0-0"/>
  <string val="outBuffer1" name="nodeOutputName-0-1"/>
  <string val="imgGenericId" name="nodeStringId-1"/>
  <uint val="1" name="nodeVersion-1"/>
  <string val="edgeDetection" name="nodeName-1"/>
  <string val="generic/" name="nodePath-1"/>
  <string val="Generic node for image processing" name="nodeDesc-1"/>
  <string val="This node was designed to create custom shaders&#xa;The settings widget allows to modify input, output parameters&#xa;as well as the output image sizes.&#xa;&#xa;WARNING1: you will be able to modify the number of inputs/outputs&#xa;only if the node is entirely disconnected.&#xa;WARNING2: input/output names will not be modified if a custom node is created&#xa;from this node because these names should be edited directly in the setting widget&#xa;WARNING3: modifying the settings of a node will remove all previously&#xa;defined keyframes&#xa;&#xa;* Special data allows to modify the output image (using a multiple of&#xa;the input size, plus an offset vector&#xa;Check use mouse/keyboard if you want to interact with the mouse&#xa;&#xa;* Input data allows to add/remove/displace input data (only if disconnected)&#xa;&#xa;* Output data allows to add/remove/displace output data (only if disconnected)&#xa;&#xa;* Param data allows to add/remove parameters that will automatically be &#xa;included in your shader.&#xa;For each of them you may choose a proper name, type, and min/max/default values.&#xa;Check keyframes if you want your parameter to be accessible&#xa; through the animation widget&#xa;&#xa;In the node interface itself:&#xa;Source tab contains the head and body of your GLSL source (only the body is editable)&#xa;Params tab contains the defined widgets according to your setting choices&#xa;Log tab contains compilation errors&#xa;&#xa;Once your settings and source completed, click on apply to see the result&#xa;" name="nodeHelp-1"/>
  <uint val="1" name="nodeId-1"/>
  <uint val="0" name="nodeGraphId-1"/>
  <vector2f name="nodePos-1">
   <float val="-558.013" name="0"/>
   <float val="1357.23" name="1"/>
  </vector2f>
  <int val="1" name="nodeInputNameSize-1"/>
  <int val="1" name="nodeOutputNameSize-1"/>
  <string val="imgBuff" name="nodeInputName-1-0"/>
  <string val="edgesBuff" name="nodeOutputName-1-0"/>
  <string val="imgLoaderId" name="nodeStringId-2"/>
  <uint val="1" name="nodeVersion-2"/>
  <string val="imgLoader" name="nodeName-2"/>
  <string val="plugins/" name="nodePath-2"/>
  <string val="Image loader" name="nodeDesc-2"/>
  <string val="Load an image." name="nodeHelp-2"/>
  <uint val="2" name="nodeId-2"/>
  <uint val="0" name="nodeGraphId-2"/>
  <vector2f name="nodePos-2">
   <float val="-265.123" name="0"/>
   <float val="382.491" name="1"/>
  </vector2f>
  <int val="0" name="nodeInputNameSize-2"/>
  <int val="1" name="nodeOutputNameSize-2"/>
  <string val="image" name="nodeOutputName-2-0"/>
  <string val="imgGenericId" name="nodeStringId-3"/>
  <uint val="1" name="nodeVersion-3"/>
  <string val="imgGeneric" name="nodeName-3"/>
  <string val="generic/" name="nodePath-3"/>
  <string val="Generic node for image processing" name="nodeDesc-3"/>
  <string val="This node was designed to create custom shaders&#xa;The settings widget allows to modify input, output parameters&#xa;as well as the output image sizes.&#xa;&#xa;WARNING1: you will be able to modify the number of inputs/outputs&#xa;only if the node is entirely disconnected.&#xa;WARNING2: input/output names will not be modified if a custom node is created&#xa;from this node because these names should be edited directly in the setting widget&#xa;WARNING3: modifying the settings of a node will remove all previously&#xa;defined keyframes&#xa;&#xa;* Special data allows to modify the output image (using a multiple of&#xa;the input size, plus an offset vector&#xa;Check use mouse/keyboard if you want to interact with the mouse&#xa;&#xa;* Input data allows to add/remove/displace input data (only if disconnected)&#xa;&#xa;* Output data allows to add/remove/displace output data (only if disconnected)&#xa;&#xa;* Param data allows to add/remove parameters that will automatically be &#xa;included in your shader.&#xa;For each of them you may choose a proper name, type, and min/max/default values.&#xa;Check keyframes if you want your parameter to be accessible&#xa; through the animation widget&#xa;&#xa;In the node interface itself:&#xa;Source tab contains the head and body of your GLSL source (only the body is editable)&#xa;Params tab contains the defined widgets according to your setting choices&#xa;Log tab contains compilation errors&#xa;&#xa;Once your settings and source completed, click on apply to see the result&#xa;" name="nodeHelp-3"/>
  <uint val="3" name="nodeId-3"/>
  <uint val="0" name="nodeGraphId-3"/>
  <vector2f name="nodePos-3">
   <float val="-263.883" name="0"/>
   <float val="-384.004" name="1"/>
  </vector2f>
  <int val="0" name="nodeInputNameSize-3"/>
  <int val="1" name="nodeOutputNameSize-3"/>
  <string val="outBuffer0" name="nodeOutputName-3-0"/>
  <string val="imgGenericId" name="nodeStringId-4"/>
  <uint val="1" name="nodeVersion-4"/>
  <string val="weightCalculation" name="nodeName-4"/>
  <string val="generic/" name="nodePath-4"/>
  <string val="Generic node for image processing" name="nodeDesc-4"/>
  <string val="This node was designed to create custom shaders&#xa;The settings widget allows to modify input, output parameters&#xa;as well as the output image sizes.&#xa;&#xa;WARNING1: you will be able to modify the number of inputs/outputs&#xa;only if the node is entirely disconnected.&#xa;WARNING2: input/output names will not be modified if a custom node is created&#xa;from this node because these names should be edited directly in the setting widget&#xa;WARNING3: modifying the settings of a node will remove all previously&#xa;defined keyframes&#xa;&#xa;* Special data allows to modify the output image (using a multiple of&#xa;the input size, plus an offset vector&#xa;Check use mouse/keyboard if you want to interact with the mouse&#xa;&#xa;* Input data allows to add/remove/displace input data (only if disconnected)&#xa;&#xa;* Output data allows to add/remove/displace output data (only if disconnected)&#xa;&#xa;* Param data allows to add/remove parameters that will automatically be &#xa;included in your shader.&#xa;For each of them you may choose a proper name, type, and min/max/default values.&#xa;Check keyframes if you want your parameter to be accessible&#xa; through the animation widget&#xa;&#xa;In the node interface itself:&#xa;Source tab contains the head and body of your GLSL source (only the body is editable)&#xa;Params tab contains the defined widgets according to your setting choices&#xa;Log tab contains compilation errors&#xa;&#xa;Once your settings and source completed, click on apply to see the result&#xa;" name="nodeHelp-4"/>
  <uint val="4" name="nodeId-4"/>
  <uint val="0" name="nodeGraphId-4"/>
  <vector2f name="nodePos-4">
   <float val="733.097" name="0"/>
   <float val="114.201" name="1"/>
  </vector2f>
  <int val="3" name="nodeInputNameSize-4"/>
  <int val="1" name="nodeOutputNameSize-4"/>
  <string val="edgesBuff" name="nodeInputName-4-0"/>
  <string val="areaBuff" name="nodeInputName-4-1"/>
  <string val="searchBuff" name="nodeInputName-4-2"/>
  <string val="weightBuff" name="nodeOutputName-4-0"/>
  <string val="imgGenericId" name="nodeStringId-5"/>
  <uint val="1" name="nodeVersion-5"/>
  <string val="neighborhoodBlending" name="nodeName-5"/>
  <string val="generic/" name="nodePath-5"/>
  <string val="Generic node for image processing" name="nodeDesc-5"/>
  <string val="This node was designed to create custom shaders&#xa;The settings widget allows to modify input, output parameters&#xa;as well as the output image sizes.&#xa;&#xa;WARNING1: you will be able to modify the number of inputs/outputs&#xa;only if the node is entirely disconnected.&#xa;WARNING2: input/output names will not be modified if a custom node is created&#xa;from this node because these names should be edited directly in the setting widget&#xa;WARNING3: modifying the settings of a node will remove all previously&#xa;defined keyframes&#xa;&#xa;* Special data allows to modify the output image (using a multiple of&#xa;the input size, plus an offset vector&#xa;Check use mouse/keyboard if you want to interact with the mouse&#xa;&#xa;* Input data allows to add/remove/displace input data (only if disconnected)&#xa;&#xa;* Output data allows to add/remove/displace output data (only if disconnected)&#xa;&#xa;* Param data allows to add/remove parameters that will automatically be &#xa;included in your shader.&#xa;For each of them you may choose a proper name, type, and min/max/default values.&#xa;Check keyframes if you want your parameter to be accessible&#xa; through the animation widget&#xa;&#xa;In the node interface itself:&#xa;Source tab contains the head and body of your GLSL source (only the body is editable)&#xa;Params tab contains the defined widgets according to your setting choices&#xa;Log tab contains compilation errors&#xa;&#xa;Once your settings and source completed, click on apply to see the result&#xa;" name="nodeHelp-5"/>
  <uint val="5" name="nodeId-5"/>
  <uint val="0" name="nodeGraphId-5"/>
  <vector2f name="nodePos-5">
   <float val="2600.35" name="0"/>
   <float val="-1103.13" name="1"/>
  </vector2f>
  <int val="2" name="nodeInputNameSize-5"/>
  <int val="1" name="nodeOutputNameSize-5"/>
  <string val="weightBuff" name="nodeInputName-5-0"/>
  <string val="imgBuff" name="nodeInputName-5-1"/>
  <string val="antialiasing" name="nodeOutputName-5-0"/>
  <uint val="1" name="nbConnections-0-1"/>
  <vector2u name="connection-0-1-0">
   <uint val="0" name="0"/>
   <uint val="0" name="1"/>
  </vector2u>
  <uint val="0" name="nbConnections-0-2"/>
  <uint val="0" name="nbConnections-0-3"/>
  <uint val="0" name="nbConnections-0-4"/>
  <uint val="1" name="nbConnections-0-5"/>
  <vector2u name="connection-0-5-0">
   <uint val="1" name="0"/>
   <uint val="1" name="1"/>
  </vector2u>
  <uint val="0" name="nbConnections-1-2"/>
  <uint val="0" name="nbConnections-1-3"/>
  <uint val="1" name="nbConnections-1-4"/>
  <vector2u name="connection-1-4-0">
   <uint val="0" name="0"/>
   <uint val="0" name="1"/>
  </vector2u>
  <uint val="0" name="nbConnections-1-5"/>
  <uint val="0" name="nbConnections-2-3"/>
  <uint val="1" name="nbConnections-2-4"/>
  <vector2u name="connection-2-4-0">
   <uint val="0" name="0"/>
   <uint val="1" name="1"/>
  </vector2u>
  <uint val="0" name="nbConnections-2-5"/>
  <uint val="1" name="nbConnections-3-4"/>
  <vector2u name="connection-3-4-0">
   <uint val="0" name="0"/>
   <uint val="2" name="1"/>
  </vector2u>
  <uint val="0" name="nbConnections-3-5"/>
  <uint val="1" name="nbConnections-4-5"/>
  <vector2u name="connection-4-5-0">
   <uint val="0" name="0"/>
   <uint val="0" name="1"/>
  </vector2u>
  <bool val="1" name="nodeHasWidget-0"/>
  <IOData name="node-0">
   <string val="420" name="genericGlslVersion"/>
   <string val="multiplicator" name="genericNodeName"/>
   <bool val="0" name="genericUseVertex"/>
   <bool val="0" name="genericUseTesselation"/>
   <bool val="0" name="genericUseGeometry"/>
   <bool val="1" name="genericUseFragment"/>
   <int val="9729" name="genericOutFilter"/>
   <int val="33071" name="genericOutWrap"/>
   <bool val="0" name="genericUseDepthTest"/>
   <bool val="0" name="genericUseBlending"/>
   <uint val="513" name="genericDepthFunc"/>
   <uint val="1" name="genericBlendSrc"/>
   <uint val="0" name="genericBlendDst"/>
   <vector4f name="genericBackground">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
    <float val="0" name="2"/>
    <float val="0" name="3"/>
   </vector4f>
   <string val="#version 420&#xa;&#xa;layout(location = 0) in vec2 vertex;&#xa;layout(location = 1) in vec2 coord;&#xa;uniform sampler2D inBuffer0;&#xa;" name="genericVertHead"/>
   <string val="out vec2 texcoord;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = vec4(vertex,0,1);&#xa;&#x9;texcoord    = coord;&#xa;}&#xa;" name="genericVertBody"/>
   <string val="#version 420&#xa;&#xa;layout(location = 0) out vec4 outBuffer0;&#xa;layout(location = 1) out vec4 outBuffer1;&#xa;uniform sampler2D inBuffer0;&#xa;" name="genericFragHead"/>
   <string val="// This node is just here to have only one input buffer. Ungroup and remove it if you want a &quot;faster&quot; algorithm.&#xa;&#xa;in vec2 texcoord;&#xa;void main() {&#xa;&#x9;outBuffer0 = texture(inBuffer0,texcoord);&#xa;&#x9;outBuffer1 = texture(inBuffer0,texcoord);&#xa;}&#xa;" name="genericFragBody"/>
   <string val="#version 420&#xa;&#xa;layout(vertices = 4) out;&#xa;uniform sampler2D inBuffer0;&#xa;" name="genericTessCHead"/>
   <string val="void main(void) {&#xa;&#x9;gl_TessLevelOuter[0] = 1;&#xa;&#x9;gl_TessLevelOuter[1] = 1;&#xa;&#x9;gl_TessLevelOuter[2] = 1;&#xa;&#x9;gl_TessLevelOuter[3] = 1;&#xa;&#x9;gl_TessLevelInner[0] = 1;&#xa;&#x9;gl_TessLevelInner[1] = 1;&#xa;&#x9;gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;&#xa;}&#xa;" name="genericTessCBody"/>
   <string val="#version 420&#xa;&#xa;uniform sampler2D inBuffer0;&#xa;" name="genericTessEHead"/>
   <string val="layout(quads,equal_spacing) in;&#xa;&#xa;void main() {&#xa;&#x9;vec4 p1 = mix(gl_in[0].gl_Position,gl_in[1].gl_Position,gl_TessCoord.x);&#xa;&#x9;vec4 p2 = mix(gl_in[3].gl_Position,gl_in[2].gl_Position,gl_TessCoord.x);&#xa;&#x9;gl_Position = mix(p1,p2,gl_TessCoord.y);&#xa;}&#xa;" name="genericTessEBody"/>
   <string val="#version 420&#xa;&#xa;layout(triangles) in;&#xa;uniform sampler2D inBuffer0;&#xa;" name="genericGeomHead"/>
   <string val="layout(triangle_strip, max_vertices = 3) out;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = gl_in[0].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[1].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[2].gl_Position; EmitVertex();&#xa;&#x9;EndPrimitive();&#xa;}" name="genericGeomBody"/>
   <vector2f name="genericTSize">
    <float val="1" name="0"/>
    <float val="1" name="1"/>
   </vector2f>
   <vector2f name="genericTOffset">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
   </vector2f>
   <bool val="0" name="genericNeedMouse"/>
   <bool val="0" name="genericNeedKeyboard"/>
   <uint val="0" name="genericNbWidgets"/>
  </IOData>
  <IOData name="nodeWidget-0">
   <uint val="0" name="nbChildren"/>
  </IOData>
  <vector2f name="nodeInputPos-0-0">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <vector2f name="nodeOutputPos-0-0">
   <float val="56.32" name="0"/>
   <float val="647.68" name="1"/>
  </vector2f>
  <vector2f name="nodeOutputPos-0-1">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <bool val="1" name="nodeHasWidget-1"/>
  <IOData name="node-1">
   <string val="420" name="genericGlslVersion"/>
   <string val="edgeDetection" name="genericNodeName"/>
   <bool val="1" name="genericUseVertex"/>
   <bool val="0" name="genericUseTesselation"/>
   <bool val="0" name="genericUseGeometry"/>
   <bool val="1" name="genericUseFragment"/>
   <int val="9729" name="genericOutFilter"/>
   <int val="33071" name="genericOutWrap"/>
   <bool val="0" name="genericUseDepthTest"/>
   <bool val="0" name="genericUseBlending"/>
   <uint val="513" name="genericDepthFunc"/>
   <uint val="1" name="genericBlendSrc"/>
   <uint val="0" name="genericBlendDst"/>
   <vector4f name="genericBackground">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
    <float val="0" name="2"/>
    <float val="0" name="3"/>
   </vector4f>
   <string val="#version 420&#xa;&#xa;layout(location = 0) in vec2 vertex;&#xa;layout(location = 1) in vec2 coord;&#xa;uniform sampler2D imgBuff;&#xa;uniform float threshold;&#xa;" name="genericVertHead"/>
   <string val="//Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)&#xa;//Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)&#xa;//Copyright (C) 2013 Belen Masia (bmasia@unizar.es)&#xa;//Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)&#xa;//Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)&#xa;&#xa;//Permission is hereby granted, free of charge, to any person obtaining a copy&#xa;//this software and associated documentation files (the &quot;Software&quot;), to deal in&#xa;//the Software without restriction, including without limitation the rights to&#xa;//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies&#xa;//of the Software, and to permit persons to whom the Software is furnished to&#xa;//do so, subject to the following conditions:&#xa;&#xa;//The above copyright notice and this permission notice shall be included in&#xa;//all copies or substantial portions of the Software. As clarification, there&#xa;//is no requirement that the copyright notice and permission be included in&#xa;//binary distributions of the Software.&#xa;&#xa;//THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xa;//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xa;//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xa;//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xa;//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xa;//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xa;//SOFTWARE.&#xa;&#xa;out vec2 texcoord;&#xa;out vec4 offset[3];&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = vec4(vertex,0,1);&#xa;&#x9;texcoord    = coord;&#xa;&#x9;vec2 pixelSize = 1.0 / textureSize(imgBuff, 0);&#xa;    offset[0] = fma(pixelSize.xyxy, vec4(-1.0, 0.0, 0.0, -1.0), texcoord.xyxy);&#xa;    offset[1] = fma(pixelSize.xyxy, vec4( 1.0, 0.0, 0.0,  1.0), texcoord.xyxy);&#xa;    offset[2] = fma(pixelSize.xyxy, vec4(-2.0, 0.0, 0.0, -2.0), texcoord.xyxy);&#xa;}" name="genericVertBody"/>
   <string val="#version 420&#xa;&#xa;layout(location = 0) out vec4 edgesBuff;&#xa;uniform sampler2D imgBuff;&#xa;uniform float threshold;&#xa;" name="genericFragHead"/>
   <string val="//Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)&#xa;//Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)&#xa;//Copyright (C) 2013 Belen Masia (bmasia@unizar.es)&#xa;//Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)&#xa;//Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)&#xa;&#xa;//Permission is hereby granted, free of charge, to any person obtaining a copy&#xa;//this software and associated documentation files (the &quot;Software&quot;), to deal in&#xa;//the Software without restriction, including without limitation the rights to&#xa;//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies&#xa;//of the Software, and to permit persons to whom the Software is furnished to&#xa;//do so, subject to the following conditions:&#xa;&#xa;//The above copyright notice and this permission notice shall be included in&#xa;//all copies or substantial portions of the Software. As clarification, there&#xa;//is no requirement that the copyright notice and permission be included in&#xa;//binary distributions of the Software.&#xa;&#xa;//THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xa;//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xa;//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xa;//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xa;//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xa;//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xa;//SOFTWARE.&#xa;&#xa;#define SMAA_RT_METRICS vec4(1.0 / textureSize(imgBuff, 0), textureSize(imgBuff, 0))&#xa;&#xa;// Configurable Defines&#xa;#ifndef SMAA_DEPTH_THRESHOLD&#xa;#define SMAA_DEPTH_THRESHOLD (0.1 * threshold)&#xa;#endif&#xa;#ifndef SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR&#xa;#define SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR 2.0&#xa;#endif&#xa;#ifndef SMAA_PREDICATION&#xa;#define SMAA_PREDICATION 0&#xa;#endif&#xa;#ifndef SMAA_PREDICATION_THRESHOLD&#xa;#define SMAA_PREDICATION_THRESHOLD 0.01&#xa;#endif&#xa;#ifndef SMAA_PREDICATION_SCALE&#xa;#define SMAA_PREDICATION_SCALE 2.0 // range[0, 5]&#xa;#endif&#xa;#ifndef SMAA_PREDICATION_STRENGTH&#xa;#define SMAA_PREDICATION_STRENGTH 0.4 // range[0, 1]&#xa;#endif&#xa;&#xa;// Misc functions&#xa;vec3 textureGatherNeighbours(vec2 texcoord,&#xa;                            vec4 offset[3],&#xa;                            sampler2D tex) {&#xa;    #ifdef textureGather&#xa;    return textureGather(tex, texcoord + SMAA_RT_METRICS.xy * vec2(-0.5, -0.5)).grb;&#xa;    #else&#xa;    float P = texture(tex, texcoord).r;&#xa;    float Pleft = texture(tex, offset[0].xy).r;&#xa;    float Ptop  = texture(tex, offset[0].zw).r;&#xa;    return vec3(P, Pleft, Ptop);&#xa;    #endif&#xa;}&#xa;&#xa;vec2 SMAACalculatePredicatedThreshold(vec2 texcoord,&#xa;                                        vec4 offset[3],&#xa;                                        sampler2D predicationTex) {&#xa;    vec3 neighbours = textureGatherNeighbours(texcoord, offset, predicationTex);&#xa;    vec2 delta = abs(neighbours.xx - neighbours.yz);&#xa;    vec2 edges = step(SMAA_PREDICATION_THRESHOLD, delta);&#xa;    return SMAA_PREDICATION_SCALE * threshold * (1.0 - SMAA_PREDICATION_STRENGTH * edges);&#xa;}&#xa;&#xa;in vec2 texcoord;&#xa;in vec4 offset[3];&#xa;&#xa;//-----------------------------------------------------------------------------&#xa;// Edge Detection Shader (First Pass)&#xa;&#xa;vec2 SMAALumaEdgeDetectionPS(vec2 texcoord,&#xa;                               vec4 offset[3],&#xa;                               sampler2D colorTex&#xa;                               #if SMAA_PREDICATION&#xa;                               , sampler2D predicationTex&#xa;                               #endif&#xa;                               ) {&#xa;    // Calculate the threshold:&#xa;    #if SMAA_PREDICATION&#xa;    vec2 inThreshold = SMAACalculatePredicatedThreshold(texcoord, offset, predicationTex);&#xa;    #else&#xa;    vec2 inThreshold = vec2(threshold, threshold);&#xa;    #endif&#xa;&#xa;    // Calculate lumas:&#xa;    vec3 weights = vec3(0.2126, 0.7152, 0.0722);&#xa;    float L = dot(texture(colorTex, texcoord).rgb, weights);&#xa;&#xa;    float Lleft = dot(texture(colorTex, offset[0].xy).rgb, weights);&#xa;    float Ltop  = dot(texture(colorTex, offset[0].zw).rgb, weights);&#xa;&#xa;    // We do the usual threshold:&#xa;    vec4 delta;&#xa;    delta.xy = abs(L - vec2(Lleft, Ltop));&#xa;    vec2 edges = step(inThreshold, delta.xy);&#xa;&#xa;    // Then discard if there is no edge:&#xa;    if (dot(edges, vec2(1.0, 1.0)) == 0.0)&#xa;        discard;&#xa;&#xa;    // Calculate right and bottom deltas:&#xa;    float Lright = dot(texture(colorTex, offset[1].xy).rgb, weights);&#xa;    float Lbottom  = dot(texture(colorTex, offset[1].zw).rgb, weights);&#xa;    delta.zw = abs(L - vec2(Lright, Lbottom));&#xa;&#xa;    // Calculate the maximum delta in the direct neighborhood:&#xa;    vec2 maxDelta = max(delta.xy, delta.zw);&#xa;&#xa;    // Calculate left-left and top-top deltas:&#xa;    float Lleftleft = dot(texture(colorTex, offset[2].xy).rgb, weights);&#xa;    float Ltoptop = dot(texture(colorTex, offset[2].zw).rgb, weights);&#xa;    delta.zw = abs(vec2(Lleft, Ltop) - vec2(Lleftleft, Ltoptop));&#xa;&#xa;    // Calculate the final maximum delta:&#xa;    maxDelta = max(maxDelta.xy, delta.zw);&#xa;    float finalDelta = max(maxDelta.x, maxDelta.y);&#xa;&#xa;    // Local contrast adaptation:&#xa;    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);&#xa;&#xa;    return edges;&#xa;}&#xa;&#xa;vec2 SMAAColorEdgeDetectionPS(vec2 texcoord,&#xa;                                vec4 offset[3],&#xa;                                sampler2D colorTex&#xa;                                #if SMAA_PREDICATION&#xa;                                , sampler2D predicationTex&#xa;                                #endif&#xa;                                ) {&#xa;    // Calculate the threshold:&#xa;    #if SMAA_PREDICATION&#xa;    vec2 inThreshold = SMAACalculatePredicatedThreshold(texcoord, offset, predicationTex);&#xa;    #else&#xa;    vec2 inThreshold = vec2(threshold, threshold);&#xa;    #endif&#xa;&#xa;    // Calculate color deltas:&#xa;    vec4 delta;&#xa;    vec3 C = texture(colorTex, texcoord).rgb;&#xa;&#xa;    vec3 Cleft = texture(colorTex, offset[0].xy).rgb;&#xa;    vec3 t = abs(C - Cleft);&#xa;    delta.x = max(max(t.r, t.g), t.b);&#xa;&#xa;    vec3 Ctop  = texture(colorTex, offset[0].zw).rgb;&#xa;    t = abs(C - Ctop);&#xa;    delta.y = max(max(t.r, t.g), t.b);&#xa;&#xa;    // We do the usual threshold:&#xa;    vec2 edges = step(inThreshold, delta.xy);&#xa;&#xa;    // Then discard if there is no edge:&#xa;    if (dot(edges, vec2(1.0, 1.0)) == 0.0)&#xa;        discard;&#xa;&#xa;    // Calculate right and bottom deltas:&#xa;    vec3 Cright = texture(colorTex, offset[1].xy).rgb;&#xa;    t = abs(C - Cright);&#xa;    delta.z = max(max(t.r, t.g), t.b);&#xa;&#xa;    vec3 Cbottom  = texture(colorTex, offset[1].zw).rgb;&#xa;    t = abs(C - Cbottom);&#xa;    delta.w = max(max(t.r, t.g), t.b);&#xa;&#xa;    // Calculate the maximum delta in the direct neighborhood:&#xa;    vec2 maxDelta = max(delta.xy, delta.zw);&#xa;&#xa;    // Calculate left-left and top-top deltas:&#xa;    vec3 Cleftleft  = texture(colorTex, offset[2].xy).rgb;&#xa;    t = abs(C - Cleftleft);&#xa;    delta.z = max(max(t.r, t.g), t.b);&#xa;&#xa;    vec3 Ctoptop = texture(colorTex, offset[2].zw).rgb;&#xa;    t = abs(C - Ctoptop);&#xa;    delta.w = max(max(t.r, t.g), t.b);&#xa;&#xa;    // Calculate the final maximum delta:&#xa;    maxDelta = max(maxDelta.xy, delta.zw);&#xa;    float finalDelta = max(maxDelta.x, maxDelta.y);&#xa;&#xa;    // Local contrast adaptation:&#xa;    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);&#xa;&#xa;    return edges;&#xa;}&#xa;&#xa;vec2 SMAADepthEdgeDetectionPS(vec2 texcoord,&#xa;                                vec4 offset[3],&#xa;                                sampler2D depthTex) {&#xa;    vec3 neighbours = textureGatherNeighbours(texcoord, offset, depthTex);&#xa;    vec2 delta = abs(neighbours.xx - vec2(neighbours.y, neighbours.z));&#xa;    vec2 edges = step(SMAA_DEPTH_THRESHOLD, delta);&#xa;&#xa;    if (dot(edges, vec2(1.0, 1.0)) == 0.0)&#xa;        discard;&#xa;&#xa;    return edges;&#xa;}&#xa;&#xa;void main() {&#xa;&#x9;vec2 edges = SMAALumaEdgeDetectionPS(texcoord, offset, imgBuff);&#xa;&#x9;//vec2 edges = SMAAColorEdgeDetectionPS(texcoord, offset, imgBuff);&#xa;&#x9;edgesBuff = vec4(edges, 0, 1);&#xa;}" name="genericFragBody"/>
   <string val="#version 420&#xa;&#xa;layout(vertices = 4) out;&#xa;uniform sampler2D imgBuff;&#xa;uniform float threshold;&#xa;" name="genericTessCHead"/>
   <string val="void main(void) {&#xa;&#x9;gl_TessLevelOuter[0] = 1;&#xa;&#x9;gl_TessLevelOuter[1] = 1;&#xa;&#x9;gl_TessLevelOuter[2] = 1;&#xa;&#x9;gl_TessLevelOuter[3] = 1;&#xa;&#x9;gl_TessLevelInner[0] = 1;&#xa;&#x9;gl_TessLevelInner[1] = 1;&#xa;&#x9;gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;&#xa;}&#xa;" name="genericTessCBody"/>
   <string val="#version 420&#xa;&#xa;uniform sampler2D imgBuff;&#xa;uniform float threshold;&#xa;" name="genericTessEHead"/>
   <string val="layout(quads,equal_spacing) in;&#xa;&#xa;void main() {&#xa;&#x9;vec4 p1 = mix(gl_in[0].gl_Position,gl_in[1].gl_Position,gl_TessCoord.x);&#xa;&#x9;vec4 p2 = mix(gl_in[3].gl_Position,gl_in[2].gl_Position,gl_TessCoord.x);&#xa;&#x9;gl_Position = mix(p1,p2,gl_TessCoord.y);&#xa;}&#xa;" name="genericTessEBody"/>
   <string val="#version 420&#xa;&#xa;layout(triangles) in;&#xa;uniform sampler2D imgBuff;&#xa;uniform float threshold;&#xa;" name="genericGeomHead"/>
   <string val="layout(triangle_strip, max_vertices = 3) out;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = gl_in[0].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[1].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[2].gl_Position; EmitVertex();&#xa;&#x9;EndPrimitive();&#xa;}" name="genericGeomBody"/>
   <vector2f name="genericTSize">
    <float val="1" name="0"/>
    <float val="1" name="1"/>
   </vector2f>
   <vector2f name="genericTOffset">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
   </vector2f>
   <bool val="0" name="genericNeedMouse"/>
   <bool val="0" name="genericNeedKeyboard"/>
   <uint val="1" name="genericNbWidgets"/>
   <int val="0" name="genericWidgetType-0"/>
   <int val="1" name="genericWidgetView-0"/>
   <string val="threshold" name="genericWidgetName-0"/>
   <bool val="0" name="genericWidgetKeyframed-0"/>
  </IOData>
  <IOData name="nodeWidget-1">
   <uint val="1" name="nbChildren"/>
   <IOData name="childWidget-0">
    <bool val="0" name="floatAttribKeyframed"/>
    <float val="0.05" name="floatAttribMinVal"/>
    <float val="0.5" name="floatAttribMaxVal"/>
    <IOData name="floatAttribCurve">
     <float val="0.05" name="currentVal"/>
     <uint val="1" name="nbCurves"/>
     <IOData name="curve-0">
      <int val="0" name="interpType"/>
      <int val="0" name="leftType"/>
      <int val="0" name="rightType"/>
      <IOData name="interpolator">
       <uint val="1" name="nbPoints"/>
       <uint val="0" name="nbTangents"/>
       <vector2f name="controlPoint-0">
        <float val="0" name="0"/>
        <float val="0.05" name="1"/>
       </vector2f>
      </IOData>
     </IOData>
    </IOData>
    <uint val="0" name="nbChildren"/>
   </IOData>
  </IOData>
  <vector2f name="nodeInputPos-1-0">
   <float val="56.32" name="0"/>
   <float val="647.68" name="1"/>
  </vector2f>
  <vector2f name="nodeOutputPos-1-0">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <bool val="1" name="nodeHasWidget-2"/>
  <IOData name="node-2">
   <string val="../../data/imgs/AreaTexGLSL.jpg" name="filename"/>
   <vector2i name="size">
    <int val="160" name="0"/>
    <int val="560" name="1"/>
   </vector2i>
  </IOData>
  <IOData name="nodeWidget-2">
   <bool val="0" name="keepAspectRatio"/>
   <bool val="0" name="keepSize"/>
  </IOData>
  <vector2f name="nodeOutputPos-2-0">
   <float val="17.6" name="0"/>
   <float val="30.8" name="1"/>
  </vector2f>
  <bool val="1" name="nodeHasWidget-3"/>
  <IOData name="node-3">
   <string val="420" name="genericGlslVersion"/>
   <string val="imgGeneric" name="genericNodeName"/>
   <bool val="0" name="genericUseVertex"/>
   <bool val="0" name="genericUseTesselation"/>
   <bool val="0" name="genericUseGeometry"/>
   <bool val="1" name="genericUseFragment"/>
   <int val="9729" name="genericOutFilter"/>
   <int val="33071" name="genericOutWrap"/>
   <bool val="0" name="genericUseDepthTest"/>
   <bool val="0" name="genericUseBlending"/>
   <uint val="513" name="genericDepthFunc"/>
   <uint val="1" name="genericBlendSrc"/>
   <uint val="0" name="genericBlendDst"/>
   <vector4f name="genericBackground">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
    <float val="0" name="2"/>
    <float val="0" name="3"/>
   </vector4f>
   <string val="#version 420&#xa;&#xa;layout(location = 0) in vec2 vertex;&#xa;layout(location = 1) in vec2 coord;&#xa;" name="genericVertHead"/>
   <string val="out vec2 texcoord;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = vec4(vertex,0,1);&#xa;&#x9;texcoord    = coord;&#xa;}&#xa;" name="genericVertBody"/>
   <string val="#version 420&#xa;&#xa;layout(location = 0) out vec4 outBuffer0;&#xa;" name="genericFragHead"/>
   <string val="in vec2 texcoord;&#xa;&#xa;float searchTexBytes[] = {&#xa;    0.99, 0.99, 0.0, 0.5, 0.5, 0.0, 0.0, 0.99, 0.99, 0.0, 0.5, 0.5, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, &#xa;    0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.99, 0.5, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.99, 0.99, 0.0, 0.5, 0.5, 0.0, 0.0, 0.99, &#xa;    0.99, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, &#xa;    0.5, 0.99, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.99, 0.99, 0.0, 0.5, 0.5, 0.0, 0.0, 0.99, 0.99, 0.0, 0.5, 0.5, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, &#xa;    0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.99, 0.5, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.99, 0.99, 0.0, 0.5, 0.5, 0.0, 0.0, 0.99, &#xa;    0.99, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, &#xa;    0.5, 0.99, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.5, &#xa;    0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, &#xa;    0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, &#xa;    0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, &#xa;    0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.5, &#xa;    0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, &#xa;    0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, &#xa;    0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, &#xa;    0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, &#xa;    0.0, 0.0, 0.0, 0.0,&#xa;};&#xa;&#xa;float getSearchTex(vec2 coord) {&#xa;&#x9;return searchTexBytes[64 * int(16.0 * coord.y) + int(64.0 * coord.x)];&#xa;}&#xa;&#xa;void main() {&#xa;&#x9;outBuffer0 = vec4(vec3(getSearchTex(texcoord)), 1);&#xa;}&#xa;" name="genericFragBody"/>
   <string val="#version 420&#xa;&#xa;layout(vertices = 4) out;&#xa;" name="genericTessCHead"/>
   <string val="void main(void) {&#xa;&#x9;gl_TessLevelOuter[0] = 1;&#xa;&#x9;gl_TessLevelOuter[1] = 1;&#xa;&#x9;gl_TessLevelOuter[2] = 1;&#xa;&#x9;gl_TessLevelOuter[3] = 1;&#xa;&#x9;gl_TessLevelInner[0] = 1;&#xa;&#x9;gl_TessLevelInner[1] = 1;&#xa;&#x9;gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;&#xa;}&#xa;" name="genericTessCBody"/>
   <string val="#version 420&#xa;&#xa;" name="genericTessEHead"/>
   <string val="layout(quads,equal_spacing) in;&#xa;&#xa;void main() {&#xa;&#x9;vec4 p1 = mix(gl_in[0].gl_Position,gl_in[1].gl_Position,gl_TessCoord.x);&#xa;&#x9;vec4 p2 = mix(gl_in[3].gl_Position,gl_in[2].gl_Position,gl_TessCoord.x);&#xa;&#x9;gl_Position = mix(p1,p2,gl_TessCoord.y);&#xa;}&#xa;" name="genericTessEBody"/>
   <string val="#version 420&#xa;&#xa;layout(triangles) in;&#xa;" name="genericGeomHead"/>
   <string val="layout(triangle_strip, max_vertices = 3) out;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = gl_in[0].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[1].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[2].gl_Position; EmitVertex();&#xa;&#x9;EndPrimitive();&#xa;}" name="genericGeomBody"/>
   <vector2f name="genericTSize">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
   </vector2f>
   <vector2f name="genericTOffset">
    <float val="64" name="0"/>
    <float val="16" name="1"/>
   </vector2f>
   <bool val="0" name="genericNeedMouse"/>
   <bool val="0" name="genericNeedKeyboard"/>
   <uint val="0" name="genericNbWidgets"/>
  </IOData>
  <IOData name="nodeWidget-3">
   <uint val="0" name="nbChildren"/>
  </IOData>
  <vector2f name="nodeOutputPos-3-0">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <bool val="1" name="nodeHasWidget-4"/>
  <IOData name="node-4">
   <string val="420" name="genericGlslVersion"/>
   <string val="weightCalculation" name="genericNodeName"/>
   <bool val="1" name="genericUseVertex"/>
   <bool val="0" name="genericUseTesselation"/>
   <bool val="0" name="genericUseGeometry"/>
   <bool val="1" name="genericUseFragment"/>
   <int val="9729" name="genericOutFilter"/>
   <int val="33071" name="genericOutWrap"/>
   <bool val="0" name="genericUseDepthTest"/>
   <bool val="0" name="genericUseBlending"/>
   <uint val="513" name="genericDepthFunc"/>
   <uint val="1" name="genericBlendSrc"/>
   <uint val="0" name="genericBlendDst"/>
   <vector4f name="genericBackground">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
    <float val="0" name="2"/>
    <float val="0" name="3"/>
   </vector4f>
   <string val="#version 420&#xa;&#xa;layout(location = 0) in vec2 vertex;&#xa;layout(location = 1) in vec2 coord;&#xa;uniform sampler2D edgesBuff;&#xa;uniform sampler2D areaBuff;&#xa;uniform sampler2D searchBuff;&#xa;uniform float scale;&#xa;" name="genericVertHead"/>
   <string val="//Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)&#xa;//Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)&#xa;//Copyright (C) 2013 Belen Masia (bmasia@unizar.es)&#xa;//Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)&#xa;//Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)&#xa;&#xa;//Permission is hereby granted, free of charge, to any person obtaining a copy&#xa;//this software and associated documentation files (the &quot;Software&quot;), to deal in&#xa;//the Software without restriction, including without limitation the rights to&#xa;//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies&#xa;//of the Software, and to permit persons to whom the Software is furnished to&#xa;//do so, subject to the following conditions:&#xa;&#xa;//The above copyright notice and this permission notice shall be included in&#xa;//all copies or substantial portions of the Software. As clarification, there&#xa;//is no requirement that the copyright notice and permission be included in&#xa;//binary distributions of the Software.&#xa;&#xa;//THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xa;//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xa;//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xa;//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xa;//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xa;//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xa;//SOFTWARE.&#xa;&#xa;#define SMAA_PRESET_ULTRA&#xa;&#xa;// SMAA Presets&#xa;#if defined(SMAA_PRESET_LOW)&#xa;#define SMAA_MAX_SEARCH_STEPS 4&#xa;#elif defined(SMAA_PRESET_MEDIUM)&#xa;#define SMAA_MAX_SEARCH_STEPS 8&#xa;#elif defined(SMAA_PRESET_HIGH)&#xa;#define SMAA_MAX_SEARCH_STEPS 16&#xa;#elif defined(SMAA_PRESET_ULTRA)&#xa;#define SMAA_MAX_SEARCH_STEPS 32&#xa;#endif&#xa;&#xa;// Configurable Defines&#xa;#ifndef SMAA_MAX_SEARCH_STEPS&#xa;#define SMAA_MAX_SEARCH_STEPS 16 // range[0, 112]&#xa;#endif&#xa;&#xa;out vec2 texcoord;&#xa;out vec2 pixcoord;&#xa;out vec4 offset[3];&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = vec4(vertex,0,1);&#xa;&#x9;texcoord    = coord;&#xa;    pixcoord = texcoord * textureSize(edgesBuff, 0);&#xa;&#x9;vec2 pixelSize = 1.0 / textureSize(edgesBuff, 0);&#xa;&#xa;    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):&#xa;    offset[0] = fma(pixelSize.xyxy, vec4(-0.25, -0.125,  1.25, -0.125), texcoord.xyxy);&#xa;    offset[1] = fma(pixelSize.xyxy, vec4(-0.125, -0.25, -0.125,  1.25), texcoord.xyxy);&#xa;&#xa;    // And these for the searches, they indicate the ends of the loops:&#xa;    offset[2] = fma(pixelSize.xxyy,&#xa;                    vec4(-2.0, 2.0, -2.0, 2.0) * float(SMAA_MAX_SEARCH_STEPS),&#xa;                    vec4(offset[0].xz, offset[1].yw));&#xa;}" name="genericVertBody"/>
   <string val="#version 420&#xa;&#xa;layout(location = 0) out vec4 weightBuff;&#xa;uniform sampler2D edgesBuff;&#xa;uniform sampler2D areaBuff;&#xa;uniform sampler2D searchBuff;&#xa;uniform float scale;&#xa;" name="genericFragHead"/>
   <string val="//Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)&#xa;//Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)&#xa;//Copyright (C) 2013 Belen Masia (bmasia@unizar.es)&#xa;//Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)&#xa;//Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)&#xa;&#xa;//Permission is hereby granted, free of charge, to any person obtaining a copy&#xa;//this software and associated documentation files (the &quot;Software&quot;), to deal in&#xa;//the Software without restriction, including without limitation the rights to&#xa;//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies&#xa;//of the Software, and to permit persons to whom the Software is furnished to&#xa;//do so, subject to the following conditions:&#xa;&#xa;//The above copyright notice and this permission notice shall be included in&#xa;//all copies or substantial portions of the Software. As clarification, there&#xa;//is no requirement that the copyright notice and permission be included in&#xa;//binary distributions of the Software.&#xa;&#xa;//THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xa;//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xa;//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xa;//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xa;//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xa;//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xa;//SOFTWARE.&#xa;&#xa;#define SMAA_RT_METRICS vec4(1.0 / textureSize(edgesBuff, 0), textureSize(edgesBuff, 0))&#xa;#define SMAA_PRESET_ULTRA&#xa;&#xa;// SMAA Presets&#xa;#if defined(SMAA_PRESET_LOW)&#xa;#define SMAA_DISABLE_DIAG_DETECTION&#xa;#define SMAA_DISABLE_CORNER_DETECTION&#xa;#elif defined(SMAA_PRESET_MEDIUM)&#xa;#define SMAA_DISABLE_DIAG_DETECTION&#xa;#define SMAA_DISABLE_CORNER_DETECTION&#xa;#elif defined(SMAA_PRESET_HIGH)&#xa;#define SMAA_MAX_SEARCH_STEPS_DIAG 8&#xa;#define SMAA_CORNER_ROUNDING 25&#xa;#elif defined(SMAA_PRESET_ULTRA)&#xa;#define SMAA_MAX_SEARCH_STEPS_DIAG 16&#xa;#define SMAA_CORNER_ROUNDING 25&#xa;#endif&#xa;&#xa;// Configurable Defines&#xa;#ifndef SMAA_MAX_SEARCH_STEPS_DIAG&#xa;#define SMAA_MAX_SEARCH_STEPS_DIAG 8 // range[0, 20]&#xa;#endif&#xa;#ifndef SMAA_CORNER_ROUNDING&#xa;#define SMAA_CORNER_ROUNDING 25 // range[0, 100]&#xa;#endif&#xa;&#xa;// Texture Access Defines&#xa;#ifndef SMAA_AREATEX_SELECT&#xa;#if defined(SMAA_HLSL_3)&#xa;#define SMAA_AREATEX_SELECT(sample) sample.ra&#xa;#else&#xa;#define SMAA_AREATEX_SELECT(sample) sample.rg&#xa;#endif&#xa;#endif&#xa;&#xa;#ifndef SMAA_SEARCHTEX_SELECT&#xa;#define SMAA_SEARCHTEX_SELECT(sample) sample.r&#xa;#endif&#xa;&#xa;// Non-Configurable Defines&#xa;#define SMAA_AREATEX_MAX_DISTANCE 16&#xa;#define SMAA_AREATEX_MAX_DISTANCE_DIAG 20&#xa;#define SMAA_AREATEX_PIXEL_SIZE (1.0 / vec2(160.0, 560.0))&#xa;#define SMAA_AREATEX_SUBTEX_SIZE (1.0 / 7.0)&#xa;#define SMAA_SEARCHTEX_SIZE vec2(66.0, 33.0)&#xa;#define SMAA_SEARCHTEX_PACKED_SIZE vec2(64.0, 16.0)&#xa;#define SMAA_CORNER_ROUNDING_NORM (float(SMAA_CORNER_ROUNDING) / 100.0)&#xa;&#xa;void SMAAMovc(bvec2 cond, inout vec2 variable, vec2 value) {&#xa;    if (cond.x) variable.x = value.x;&#xa;    if (cond.y) variable.y = value.y;&#xa;}&#xa;&#xa;void SMAAMovc(bvec4 cond, inout vec4 variable, vec4 value) {&#xa;    SMAAMovc(cond.xy, variable.xy, value.xy);&#xa;    SMAAMovc(cond.zw, variable.zw, value.zw);&#xa;}&#xa;&#xa;//-----------------------------------------------------------------------------&#xa;// Diagonal Search Functions&#xa;&#xa;#if !defined(SMAA_DISABLE_DIAG_DETECTION)&#xa;&#xa;vec2 SMAADecodeDiagBilinearAccess(vec2 e) {&#xa;    // Bilinear access for fetching 'e' have a 0.25 offset, and we are&#xa;    // interested in the R and G edges:&#xa;    //&#xa;    // +---G---+-------+&#xa;    // |   x o R   x   |&#xa;    // +-------+-------+&#xa;    //&#xa;    // Then, if one of these edge is enabled:&#xa;    //   Red:   (0.75 * X + 0.25 * 1) => 0.25 or 1.0&#xa;    //   Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0&#xa;    //&#xa;    // This function will unpack the values (fma + mul + round):&#xa;    // wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1&#xa;    e.r = e.r * abs(5.0 * e.r - 5.0 * 0.75);&#xa;    return round(e);&#xa;}&#xa;&#xa;vec4 SMAADecodeDiagBilinearAccess(vec4 e) {&#xa;    e.rb = e.rb * abs(5.0 * e.rb - 5.0 * 0.75);&#xa;    return round(e);&#xa;}&#xa;&#xa;vec2 SMAASearchDiag1(sampler2D edgesTex, vec2 texcoord, vec2 dir, out vec2 e) {&#xa;    vec4 coord = vec4(texcoord, -1.0, 1.0);&#xa;    vec3 t = vec3(SMAA_RT_METRICS.xy, 1.0);&#xa;    while (coord.z &lt; float(SMAA_MAX_SEARCH_STEPS_DIAG - 1) &amp;&amp;&#xa;           coord.w > 0.9) {&#xa;        coord.xyz = fma(t, vec3(dir, 1.0), coord.xyz);&#xa;        e = textureLod(edgesTex, coord.xy, 0.0).rg;&#xa;        coord.w = dot(e, vec2(0.5, 0.5));&#xa;    }&#xa;    return coord.zw;&#xa;}&#xa;&#xa;vec2 SMAASearchDiag2(sampler2D edgesTex, vec2 texcoord, vec2 dir, out vec2 e) {&#xa;    vec4 coord = vec4(texcoord, -1.0, 1.0);&#xa;    coord.x += 0.25 * SMAA_RT_METRICS.x; // See @SearchDiag2Optimization&#xa;    vec3 t = vec3(SMAA_RT_METRICS.xy, 1.0);&#xa;    while (coord.z &lt; float(SMAA_MAX_SEARCH_STEPS_DIAG - 1) &amp;&amp;&#xa;           coord.w > 0.9) {&#xa;        coord.xyz = fma(t, vec3(dir, 1.0), coord.xyz);&#xa;&#xa;        // @SearchDiag2Optimization&#xa;        // Fetch both edges at once using bilinear filtering:&#xa;        e = textureLod(edgesTex, coord.xy, 0.0).rg;&#xa;        e = SMAADecodeDiagBilinearAccess(e);&#xa;&#xa;        // Non-optimized version:&#xa;        // e.g = textureLod(edgesTex, coord.xy, 0.0).g;&#xa;        // e.r = textureLodOffset(edgesTex, coord.xy, 0.0, ivec2(1, 0)).r;&#xa;&#xa;        coord.w = dot(e, vec2(0.5, 0.5));&#xa;    }&#xa;    return coord.zw;&#xa;}&#xa;&#xa;vec2 SMAAAreaDiag(sampler2D areaTex, vec2 dist, vec2 e, float offset) {&#xa;    vec2 texcoord = fma(vec2(SMAA_AREATEX_MAX_DISTANCE_DIAG, SMAA_AREATEX_MAX_DISTANCE_DIAG), e, dist);&#xa;&#xa;    // We do a scale and bias for mapping to texel space:&#xa;    texcoord = fma(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);&#xa;&#xa;    // Diagonal areas are on the second half of the texture:&#xa;    texcoord.x += 0.5;&#xa;&#xa;    // Move to proper place, according to the subpixel offset:&#xa;    texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;&#xa;&#xa;    // Do it!&#xa;    return SMAA_AREATEX_SELECT(textureLod(areaTex, texcoord, 0.0));&#xa;}&#xa;&#xa;vec2 SMAACalculateDiagWeights(sampler2D edgesTex, sampler2D areaTex, vec2 texcoord, vec2 e, vec4 subsampleIndices) {&#xa;    vec2 weights = vec2(0.0, 0.0);&#xa;&#xa;    // Search for the line ends:&#xa;    vec4 d;&#xa;    vec2 end;&#xa;    if (e.r > 0.0) {&#xa;        d.xz = SMAASearchDiag1(edgesTex, texcoord, vec2(-1.0,  1.0), end);&#xa;        d.x += float(end.y > 0.9);&#xa;    } else&#xa;        d.xz = vec2(0.0, 0.0);&#xa;    d.yw = SMAASearchDiag1(edgesTex, texcoord, vec2(1.0, -1.0), end);&#xa;&#xa;    if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3&#xa;        // Fetch the crossing edges:&#xa;        vec4 coords = fma(vec4(-d.x + 0.25, d.x, d.y, -d.y - 0.25), SMAA_RT_METRICS.xyxy, texcoord.xyxy);&#xa;        vec4 c;&#xa;        c.xy = textureLodOffset(edgesTex, coords.xy, 0.0, ivec2(-1,  0)).rg;&#xa;        c.zw = textureLodOffset(edgesTex, coords.zw, 0.0, ivec2( 1,  0)).rg;&#xa;        c.yxwz = SMAADecodeDiagBilinearAccess(c.xyzw);&#xa;&#xa;        // Non-optimized version:&#xa;        // vec4 coords = fma(vec4(-d.x, d.x, d.y, -d.y), SMAA_RT_METRICS.xyxy, texcoord.xyxy);&#xa;        // vec4 c;&#xa;        // c.x = textureLodOffset(edgesTex, coords.xy, 0.0, ivec2(-1,  0)).g;&#xa;        // c.y = textureLodOffset(edgesTex, coords.xy, 0.0, ivec2( 0,  0)).r;&#xa;        // c.z = textureLodOffset(edgesTex, coords.zw, 0.0, ivec2( 1,  0)).g;&#xa;        // c.w = textureLodOffset(edgesTex, coords.zw, 0.0, ivec2( 1, -1)).r;&#xa;&#xa;        // Merge crossing edges at each side into a single value:&#xa;        vec2 cc = fma(vec2(2.0, 2.0), c.xz, c.yw);&#xa;&#xa;        // Remove the crossing edge if we didn't found the end of the line:&#xa;        SMAAMovc(bvec2(step(0.9, d.zw)), cc, vec2(0.0, 0.0));&#xa;&#xa;        // Fetch the areas for this line:&#xa;        weights += SMAAAreaDiag(areaTex, d.xy, cc, subsampleIndices.z);&#xa;    }&#xa;&#xa;    // Search for the line ends:&#xa;    d.xz = SMAASearchDiag2(edgesTex, texcoord, vec2(-1.0, -1.0), end);&#xa;    if (textureLodOffset(edgesTex, texcoord, 0.0, ivec2(1, 0)).r > 0.0) {&#xa;        d.yw = SMAASearchDiag2(edgesTex, texcoord, vec2(1.0, 1.0), end);&#xa;        d.y += float(end.y > 0.9);&#xa;    } else&#xa;        d.yw = vec2(0.0, 0.0);&#xa;&#xa;    if (d.x + d.y > 2.0) { // d.x + d.y + 1 > 3&#xa;        // Fetch the crossing edges:&#xa;        vec4 coords = fma(vec4(-d.x, -d.x, d.y, d.y), SMAA_RT_METRICS.xyxy, texcoord.xyxy);&#xa;        vec4 c;&#xa;        c.x  = textureLodOffset(edgesTex, coords.xy, 0.0, ivec2(-1,  0)).g;&#xa;        c.y  = textureLodOffset(edgesTex, coords.xy, 0.0, ivec2( 0, -1)).r;&#xa;        c.zw = textureLodOffset(edgesTex, coords.zw, 0.0, ivec2( 1,  0)).gr;&#xa;        vec2 cc = fma(vec2(2.0, 2.0), c.xz, c.yw);&#xa;&#xa;        // Remove the crossing edge if we didn't found the end of the line:&#xa;        SMAAMovc(bvec2(step(0.9, d.zw)), cc, vec2(0.0, 0.0));&#xa;&#xa;        // Fetch the areas for this line:&#xa;        weights += SMAAAreaDiag(areaTex, d.xy, cc, subsampleIndices.w).gr;&#xa;    }&#xa;&#xa;    return weights;&#xa;}&#xa;#endif&#xa;&#xa;//-----------------------------------------------------------------------------&#xa;// Horizontal/Vertical Search Functions&#xa;&#xa;float SMAASearchLength(sampler2D searchTex, vec2 e, float offset) {&#xa;    // The texture is flipped vertically, with left and right cases taking half&#xa;    // of the space horizontally:&#xa;    vec2 scale = SMAA_SEARCHTEX_SIZE * vec2(0.5, -1.0);&#xa;    vec2 bias = SMAA_SEARCHTEX_SIZE * vec2(offset, 1.0);&#xa;&#xa;    // Scale and bias to access texel centers:&#xa;    scale += vec2(-1.0,  1.0);&#xa;    bias  += vec2( 0.5, -0.5);&#xa;&#xa;    // Convert from pixel coordinates to texcoords:&#xa;    // (We use SMAA_SEARCHTEX_PACKED_SIZE because the texture is cropped)&#xa;    scale *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;&#xa;    bias *= 1.0 / SMAA_SEARCHTEX_PACKED_SIZE;&#xa;&#xa;    // Lookup the search texture:&#xa;    return SMAA_SEARCHTEX_SELECT(textureLod(searchTex, fma(scale, e, bias), 0.0));&#xa;}&#xa;&#xa;float SMAASearchXLeft(sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end) {&#xa;    vec2 e = vec2(0.0, 1.0);&#xa;    while (texcoord.x > end &amp;&amp; &#xa;           e.g > 0.8281 &amp;&amp; // Is there some edge not activated?&#xa;           e.r == 0.0) { // Or is there a crossing edge that breaks the line?&#xa;        e = textureLod(edgesTex, texcoord, 0.0).rg;&#xa;        texcoord = fma(-vec2(2.0, 0.0), SMAA_RT_METRICS.xy, texcoord);&#xa;    }&#xa;&#xa;    float offset = fma(-(255.0 / 127.0), SMAASearchLength(searchTex, e, 0.0), 3.25);&#xa;    return fma(SMAA_RT_METRICS.x, offset, texcoord.x);&#xa;&#xa;    // Non-optimized version:&#xa;    // We correct the previous (-0.25, -0.125) offset we applied:&#xa;    // texcoord.x += 0.25 * SMAA_RT_METRICS.x;&#xa;&#xa;    // The searches are bias by 1, so adjust the coords accordingly:&#xa;    // texcoord.x += SMAA_RT_METRICS.x;&#xa;&#xa;    // Disambiguate the length added by the last step:&#xa;    // texcoord.x += 2.0 * SMAA_RT_METRICS.x; // Undo last step&#xa;    // texcoord.x -= SMAA_RT_METRICS.x * (255.0 / 127.0) * SMAASearchLength(searchTex, e, 0.0);&#xa;    // return fma(SMAA_RT_METRICS.x, offset, texcoord.x);&#xa;}&#xa;&#xa;float SMAASearchXRight(sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end) {&#xa;    vec2 e = vec2(0.0, 1.0);&#xa;    while (texcoord.x &lt; end &amp;&amp; &#xa;           e.g > 0.8281 &amp;&amp; // Is there some edge not activated?&#xa;           e.r == 0.0) { // Or is there a crossing edge that breaks the line?&#xa;        e = textureLod(edgesTex, texcoord, 0.0).rg;&#xa;        texcoord = fma(vec2(2.0, 0.0), SMAA_RT_METRICS.xy, texcoord);&#xa;    }&#xa;    float offset = fma(-(255.0 / 127.0), SMAASearchLength(searchTex, e, 0.5), 3.25);&#xa;    return fma(-SMAA_RT_METRICS.x, offset, texcoord.x);&#xa;}&#xa;&#xa;float SMAASearchYUp(sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end) {&#xa;    vec2 e = vec2(1.0, 0.0);&#xa;    while (texcoord.y > end &amp;&amp; &#xa;           e.r > 0.8281 &amp;&amp; // Is there some edge not activated?&#xa;           e.g == 0.0) { // Or is there a crossing edge that breaks the line?&#xa;        e = textureLod(edgesTex, texcoord, 0.0).rg;&#xa;        texcoord = fma(-vec2(0.0, 2.0), SMAA_RT_METRICS.xy, texcoord);&#xa;    }&#xa;    float offset = fma(-(255.0 / 127.0), SMAASearchLength(searchTex, e.gr, 0.0), 3.25);&#xa;    return fma(SMAA_RT_METRICS.y, offset, texcoord.y);&#xa;}&#xa;&#xa;float SMAASearchYDown(sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end) {&#xa;    vec2 e = vec2(1.0, 0.0);&#xa;    while (texcoord.y &lt; end &amp;&amp; &#xa;           e.r > 0.8281 &amp;&amp; // Is there some edge not activated?&#xa;           e.g == 0.0) { // Or is there a crossing edge that breaks the line?&#xa;        e = textureLod(edgesTex, texcoord, 0.0).rg;&#xa;        texcoord = fma(vec2(0.0, 2.0), SMAA_RT_METRICS.xy, texcoord);&#xa;    }&#xa;    float offset = fma(-(255.0 / 127.0), SMAASearchLength(searchTex, e.gr, 0.5), 3.25);&#xa;    return fma(-SMAA_RT_METRICS.y, offset, texcoord.y);&#xa;}&#xa;&#xa;vec2 SMAAArea(sampler2D areaTex, vec2 dist, float e1, float e2, float offset) {&#xa;    // Rounding prevents precision errors of bilinear filtering:&#xa;    vec2 texcoord = fma(vec2(SMAA_AREATEX_MAX_DISTANCE, SMAA_AREATEX_MAX_DISTANCE), round(4.0 * vec2(e1, e2)), dist);&#xa;    &#xa;    // We do a scale and bias for mapping to texel space:&#xa;    texcoord = fma(SMAA_AREATEX_PIXEL_SIZE, texcoord, 0.5 * SMAA_AREATEX_PIXEL_SIZE);&#xa;&#xa;    // Move to proper place, according to the subpixel offset:&#xa;    texcoord.y = fma(SMAA_AREATEX_SUBTEX_SIZE, offset, texcoord.y);&#xa;&#xa;    // Do it!&#xa;    return SMAA_AREATEX_SELECT(textureLod(areaTex, texcoord, 0.0));&#xa;}&#xa;&#xa;//-----------------------------------------------------------------------------&#xa;// Corner Detection Functions&#xa;&#xa;void SMAADetectHorizontalCornerPattern(sampler2D edgesTex, inout vec2 weights, vec4 texcoord, vec2 d) {&#xa;    #if !defined(SMAA_DISABLE_CORNER_DETECTION)&#xa;    vec2 leftRight = step(d.xy, d.yx);&#xa;    vec2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;&#xa;&#xa;    rounding /= leftRight.x + leftRight.y; // Reduce blending for pixels in the center of a line.&#xa;&#xa;    vec2 factor = vec2(1.0, 1.0);&#xa;    factor.x -= rounding.x * textureLodOffset(edgesTex, texcoord.xy, 0.0, ivec2(0,  1)).r;&#xa;    factor.x -= rounding.y * textureLodOffset(edgesTex, texcoord.zw, 0.0, ivec2(1,  1)).r;&#xa;    factor.y -= rounding.x * textureLodOffset(edgesTex, texcoord.xy, 0.0, ivec2(0, -2)).r;&#xa;    factor.y -= rounding.y * textureLodOffset(edgesTex, texcoord.zw, 0.0, ivec2(1, -2)).r;&#xa;&#xa;    weights *= clamp(factor, 0.0, 1.0);&#xa;    #endif&#xa;}&#xa;&#xa;void SMAADetectVerticalCornerPattern(sampler2D edgesTex, inout vec2 weights, vec4 texcoord, vec2 d) {&#xa;    #if !defined(SMAA_DISABLE_CORNER_DETECTION)&#xa;    vec2 leftRight = step(d.xy, d.yx);&#xa;    vec2 rounding = (1.0 - SMAA_CORNER_ROUNDING_NORM) * leftRight;&#xa;&#xa;    rounding /= leftRight.x + leftRight.y;&#xa;&#xa;    vec2 factor = vec2(1.0, 1.0);&#xa;    factor.x -= rounding.x * textureLodOffset(edgesTex, texcoord.xy, 0.0, ivec2( 1, 0)).g;&#xa;    factor.x -= rounding.y * textureLodOffset(edgesTex, texcoord.zw, 0.0, ivec2( 1, 1)).g;&#xa;    factor.y -= rounding.x * textureLodOffset(edgesTex, texcoord.xy, 0.0, ivec2(-2, 0)).g;&#xa;    factor.y -= rounding.y * textureLodOffset(edgesTex, texcoord.zw, 0.0, ivec2(-2, 1)).g;&#xa;&#xa;    weights *= clamp(factor, 0.0, 1.0);&#xa;    #endif&#xa;}&#xa;&#xa;//-----------------------------------------------------------------------------&#xa;// Blending Weight Calculation Pixel Shader (Second Pass)&#xa;&#xa;vec4 SMAABlendingWeightCalculationPS(vec2 texcoord,&#xa;                                       vec2 pixcoord,&#xa;                                       vec4 offset[3],&#xa;                                       sampler2D edgesTex,&#xa;                                       sampler2D areaTex,&#xa;                                       sampler2D searchTex,&#xa;                                       vec4 subsampleIndices) { // Just pass zero for SMAA 1x, see @SUBSAMPLE_INDICES.&#xa;    vec4 weights = vec4(0.0, 0.0, 0.0, 0.0);&#xa;&#xa;    vec2 e = texture(edgesTex, texcoord).rg;&#xa;&#xa;    if (e.g > 0.0) { // Edge at north&#xa;        #if !defined(SMAA_DISABLE_DIAG_DETECTION)&#xa;        // Diagonals have both north and west edges, so searching for them in&#xa;        // one of the boundaries is enough.&#xa;        weights.rg = SMAACalculateDiagWeights(edgesTex, areaTex, texcoord, e, subsampleIndices);&#xa;&#xa;        // We give priority to diagonals, so if we find a diagonal we skip &#xa;        // horizontal/vertical processing.&#xa;        if (weights.r == -weights.g) { // weights.r + weights.g == 0.0&#xa;        #endif&#xa;&#xa;        vec2 d;&#xa;&#xa;        // Find the distance to the left:&#xa;        vec3 coords;&#xa;        coords.x = SMAASearchXLeft(edgesTex, searchTex, offset[0].xy, offset[2].x);&#xa;        coords.y = offset[1].y; // offset[1].y = texcoord.y - 0.25 * SMAA_RT_METRICS.y (@CROSSING_OFFSET)&#xa;        d.x = coords.x;&#xa;&#xa;        // Now fetch the left crossing edges, two at a time using bilinear&#xa;        // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to&#xa;        // discern what value each edge has:&#xa;        float e1 = textureLod(edgesTex, coords.xy, 0.0).r;&#xa;&#xa;        // Find the distance to the right:&#xa;        coords.z = SMAASearchXRight(edgesTex, searchTex, offset[0].zw, offset[2].y);&#xa;        d.y = coords.z;&#xa;&#xa;        // We want the distances to be in pixel units (doing this here allow to&#xa;        // better interleave arithmetic and memory accesses):&#xa;        d = abs(round(fma(SMAA_RT_METRICS.zz, d, -pixcoord.xx)));&#xa;&#xa;        // SMAAArea below needs a sqrt, as the areas texture is compressed&#xa;        // quadratically:&#xa;        vec2 sqrt_d = sqrt(d);&#xa;&#xa;        // Fetch the right crossing edges:&#xa;        float e2 = textureLodOffset(edgesTex, coords.zy, 0.0, ivec2(1, 0)).r;&#xa;&#xa;        // Ok, we know how this pattern looks like, now it is time for getting&#xa;        // the actual area:&#xa;        weights.rg = SMAAArea(areaTex, sqrt_d, e1, e2, subsampleIndices.y);&#xa;&#xa;        // Fix corners:&#xa;        coords.y = texcoord.y;&#xa;        SMAADetectHorizontalCornerPattern(edgesTex, weights.rg, coords.xyzy, d);&#xa;&#xa;        #if !defined(SMAA_DISABLE_DIAG_DETECTION)&#xa;        } else&#xa;            e.r = 0.0; // Skip vertical processing.&#xa;        #endif&#xa;    }&#xa;&#xa;    if (e.r > 0.0) { // Edge at west&#xa;        vec2 d;&#xa;&#xa;        // Find the distance to the top:&#xa;        vec3 coords;&#xa;        coords.y = SMAASearchYUp(edgesTex, searchTex, offset[1].xy, offset[2].z);&#xa;        coords.x = offset[0].x; // offset[1].x = texcoord.x - 0.25 * SMAA_RT_METRICS.x;&#xa;        d.x = coords.y;&#xa;&#xa;        // Fetch the top crossing edges:&#xa;        float e1 = textureLod(edgesTex, coords.xy, 0.0).g;&#xa;&#xa;        // Find the distance to the bottom:&#xa;        coords.z = SMAASearchYDown(edgesTex, searchTex, offset[1].zw, offset[2].w);&#xa;        d.y = coords.z;&#xa;&#xa;        // We want the distances to be in pixel units:&#xa;        d = abs(round(fma(SMAA_RT_METRICS.ww, d, -pixcoord.yy)));&#xa;&#xa;        // SMAAArea below needs a sqrt, as the areas texture is compressed &#xa;        // quadratically:&#xa;        vec2 sqrt_d = sqrt(d);&#xa;&#xa;        // Fetch the bottom crossing edges:&#xa;        float e2 = textureLodOffset(edgesTex, coords.xz, 0.0, ivec2(0, 1)).g;&#xa;&#xa;        // Get the area for this direction:&#xa;        weights.ba = SMAAArea(areaTex, sqrt_d, e1, e2, subsampleIndices.x);&#xa;&#xa;        // Fix corners:&#xa;        coords.x = texcoord.x;&#xa;        SMAADetectVerticalCornerPattern(edgesTex, weights.ba, coords.xyxz, d);&#xa;    }&#xa;&#xa;    return weights;&#xa;}&#xa;&#xa;in vec2 texcoord;&#xa;in vec2 pixcoord;&#xa;in vec4 offset[3];&#xa;&#xa;void main() {&#xa;&#x9;vec4 subsampleIndices = vec4(0);&#xa;&#x9;weightBuff = SMAABlendingWeightCalculationPS(texcoord,&#xa;                                       pixcoord,&#xa;                                       offset,&#xa;                                       edgesBuff,&#xa;                                       areaBuff,&#xa;                                       searchBuff,&#xa;                                       subsampleIndices);&#xa;&#x9;weightBuff *= scale;&#xa;}" name="genericFragBody"/>
   <string val="#version 420&#xa;&#xa;layout(vertices = 4) out;&#xa;uniform sampler2D edgesBuff;&#xa;uniform sampler2D areaBuff;&#xa;uniform sampler2D searchBuff;&#xa;uniform float scale;&#xa;" name="genericTessCHead"/>
   <string val="void main(void) {&#xa;&#x9;gl_TessLevelOuter[0] = 1;&#xa;&#x9;gl_TessLevelOuter[1] = 1;&#xa;&#x9;gl_TessLevelOuter[2] = 1;&#xa;&#x9;gl_TessLevelOuter[3] = 1;&#xa;&#x9;gl_TessLevelInner[0] = 1;&#xa;&#x9;gl_TessLevelInner[1] = 1;&#xa;&#x9;gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;&#xa;}&#xa;" name="genericTessCBody"/>
   <string val="#version 420&#xa;&#xa;uniform sampler2D edgesBuff;&#xa;uniform sampler2D areaBuff;&#xa;uniform sampler2D searchBuff;&#xa;uniform float scale;&#xa;" name="genericTessEHead"/>
   <string val="layout(quads,equal_spacing) in;&#xa;&#xa;void main() {&#xa;&#x9;vec4 p1 = mix(gl_in[0].gl_Position,gl_in[1].gl_Position,gl_TessCoord.x);&#xa;&#x9;vec4 p2 = mix(gl_in[3].gl_Position,gl_in[2].gl_Position,gl_TessCoord.x);&#xa;&#x9;gl_Position = mix(p1,p2,gl_TessCoord.y);&#xa;}&#xa;" name="genericTessEBody"/>
   <string val="#version 420&#xa;&#xa;layout(triangles) in;&#xa;uniform sampler2D edgesBuff;&#xa;uniform sampler2D areaBuff;&#xa;uniform sampler2D searchBuff;&#xa;uniform float scale;&#xa;" name="genericGeomHead"/>
   <string val="layout(triangle_strip, max_vertices = 3) out;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = gl_in[0].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[1].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[2].gl_Position; EmitVertex();&#xa;&#x9;EndPrimitive();&#xa;}" name="genericGeomBody"/>
   <vector2f name="genericTSize">
    <float val="1" name="0"/>
    <float val="1" name="1"/>
   </vector2f>
   <vector2f name="genericTOffset">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
   </vector2f>
   <bool val="0" name="genericNeedMouse"/>
   <bool val="0" name="genericNeedKeyboard"/>
   <uint val="1" name="genericNbWidgets"/>
   <int val="0" name="genericWidgetType-0"/>
   <int val="1" name="genericWidgetView-0"/>
   <string val="scale" name="genericWidgetName-0"/>
   <bool val="0" name="genericWidgetKeyframed-0"/>
  </IOData>
  <IOData name="nodeWidget-4">
   <uint val="1" name="nbChildren"/>
   <IOData name="childWidget-0">
    <bool val="0" name="floatAttribKeyframed"/>
    <float val="1" name="floatAttribMinVal"/>
    <float val="2" name="floatAttribMaxVal"/>
    <IOData name="floatAttribCurve">
     <float val="1" name="currentVal"/>
     <uint val="1" name="nbCurves"/>
     <IOData name="curve-0">
      <int val="0" name="interpType"/>
      <int val="0" name="leftType"/>
      <int val="0" name="rightType"/>
      <IOData name="interpolator">
       <uint val="1" name="nbPoints"/>
       <uint val="0" name="nbTangents"/>
       <vector2f name="controlPoint-0">
        <float val="0" name="0"/>
        <float val="1" name="1"/>
       </vector2f>
      </IOData>
     </IOData>
    </IOData>
    <uint val="0" name="nbChildren"/>
   </IOData>
  </IOData>
  <vector2f name="nodeInputPos-4-0">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <vector2f name="nodeInputPos-4-1">
   <float val="17.6" name="0"/>
   <float val="30.8" name="1"/>
  </vector2f>
  <vector2f name="nodeInputPos-4-2">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <vector2f name="nodeOutputPos-4-0">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <bool val="1" name="nodeHasWidget-5"/>
  <IOData name="node-5">
   <string val="420" name="genericGlslVersion"/>
   <string val="neighborhoodBlending" name="genericNodeName"/>
   <bool val="1" name="genericUseVertex"/>
   <bool val="0" name="genericUseTesselation"/>
   <bool val="0" name="genericUseGeometry"/>
   <bool val="1" name="genericUseFragment"/>
   <int val="9729" name="genericOutFilter"/>
   <int val="33071" name="genericOutWrap"/>
   <bool val="0" name="genericUseDepthTest"/>
   <bool val="0" name="genericUseBlending"/>
   <uint val="513" name="genericDepthFunc"/>
   <uint val="1" name="genericBlendSrc"/>
   <uint val="0" name="genericBlendDst"/>
   <vector4f name="genericBackground">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
    <float val="0" name="2"/>
    <float val="0" name="3"/>
   </vector4f>
   <string val="#version 420&#xa;&#xa;layout(location = 0) in vec2 vertex;&#xa;layout(location = 1) in vec2 coord;&#xa;uniform sampler2D weightBuff;&#xa;uniform sampler2D imgBuff;&#xa;" name="genericVertHead"/>
   <string val="//Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)&#xa;//Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)&#xa;//Copyright (C) 2013 Belen Masia (bmasia@unizar.es)&#xa;//Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)&#xa;//Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)&#xa;&#xa;//Permission is hereby granted, free of charge, to any person obtaining a copy&#xa;//this software and associated documentation files (the &quot;Software&quot;), to deal in&#xa;//the Software without restriction, including without limitation the rights to&#xa;//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies&#xa;//of the Software, and to permit persons to whom the Software is furnished to&#xa;//do so, subject to the following conditions:&#xa;&#xa;//The above copyright notice and this permission notice shall be included in&#xa;//all copies or substantial portions of the Software. As clarification, there&#xa;//is no requirement that the copyright notice and permission be included in&#xa;//binary distributions of the Software.&#xa;&#xa;//THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xa;//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xa;//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xa;//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xa;//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xa;//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xa;//SOFTWARE.&#xa;&#xa;out vec2 texcoord;&#xa;out vec4 offset;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = vec4(vertex,0,1);&#xa;&#x9;texcoord    = coord;&#xa;&#x9;vec2 pixelSize = 1.0 / textureSize(imgBuff, 0);&#xa;    offset = fma(pixelSize.xyxy, vec4( 1.0, 0.0, 0.0,  1.0), texcoord.xyxy);&#xa;}&#xa;" name="genericVertBody"/>
   <string val="#version 420&#xa;&#xa;layout(location = 0) out vec4 antialiasing;&#xa;uniform sampler2D weightBuff;&#xa;uniform sampler2D imgBuff;&#xa;" name="genericFragHead"/>
   <string val="//Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)&#xa;//Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)&#xa;//Copyright (C) 2013 Belen Masia (bmasia@unizar.es)&#xa;//Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)&#xa;//Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)&#xa;&#xa;//Permission is hereby granted, free of charge, to any person obtaining a copy&#xa;//this software and associated documentation files (the &quot;Software&quot;), to deal in&#xa;//the Software without restriction, including without limitation the rights to&#xa;//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies&#xa;//of the Software, and to permit persons to whom the Software is furnished to&#xa;//do so, subject to the following conditions:&#xa;&#xa;//The above copyright notice and this permission notice shall be included in&#xa;//all copies or substantial portions of the Software. As clarification, there&#xa;//is no requirement that the copyright notice and permission be included in&#xa;//binary distributions of the Software.&#xa;&#xa;//THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xa;//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xa;//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xa;//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xa;//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xa;//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xa;//SOFTWARE.&#xa;&#xa;#define SMAA_RT_METRICS vec4(1.0 / textureSize(weightBuff, 0), textureSize(weightBuff, 0))&#xa;&#xa;// Configurable Defines&#xa;#ifndef SMAA_REPROJECTION&#xa;#define SMAA_REPROJECTION 0&#xa;#endif&#xa;&#xa;#ifndef SMAA_DECODE_VELOCITY&#xa;#define SMAA_DECODE_VELOCITY(sample) sample.rg&#xa;#endif&#xa;&#xa;// Misc functions&#xa;&#xa;void SMAAMovc(bvec2 cond, inout vec2 variable, vec2 value) {&#xa;    if (cond.x) variable.x = value.x;&#xa;    if (cond.y) variable.y = value.y;&#xa;}&#xa;&#xa;void SMAAMovc(bvec4 cond, inout vec4 variable, vec4 value) {&#xa;    SMAAMovc(cond.xy, variable.xy, value.xy);&#xa;    SMAAMovc(cond.zw, variable.zw, value.zw);&#xa;}&#xa;&#xa;//-----------------------------------------------------------------------------&#xa;// Neighborhood Blending Pixel Shader (Third Pass)&#xa;&#xa;vec4 SMAANeighborhoodBlendingPS(vec2 texcoord,&#xa;                                  vec4 offset,&#xa;                                  sampler2D colorTex,&#xa;                                  sampler2D blendTex&#xa;                                  #if SMAA_REPROJECTION&#xa;                                  , sampler2D velocityTex&#xa;                                  #endif&#xa;                                  ) {&#xa;    // Fetch the blending weights for current pixel:&#xa;    vec4 a;&#xa;    a.x = texture(blendTex, offset.xy).a; // Right&#xa;    a.y = texture(blendTex, offset.zw).g; // Top&#xa;    a.wz = texture(blendTex, texcoord).xz; // Bottom / Left&#xa;&#xa;    // Is there any blending weight with a value greater than 0.0?&#xa;    if (dot(a, vec4(1.0, 1.0, 1.0, 1.0)) &lt; 1e-5) {&#xa;        vec4 color = textureLod(colorTex, texcoord, 0.0);&#xa;&#xa;        #if SMAA_REPROJECTION&#xa;        vec2 velocity = SMAA_DECODE_VELOCITY(textureLod(velocityTex, texcoord, 0.0));&#xa;&#xa;        // Pack velocity into the alpha channel:&#xa;        color.a = sqrt(5.0 * length(velocity));&#xa;        #endif&#xa;&#xa;        return color;&#xa;    } else {&#xa;        bool h = max(a.x, a.z) > max(a.y, a.w); // max(horizontal) > max(vertical)&#xa;&#xa;        // Calculate the blending offsets:&#xa;        vec4 blendingOffset = vec4(0.0, a.y, 0.0, a.w);&#xa;        vec2 blendingWeight = a.yw;&#xa;        SMAAMovc(bvec4(h, h, h, h), blendingOffset, vec4(a.x, 0.0, a.z, 0.0));&#xa;        SMAAMovc(bvec2(h, h), blendingWeight, a.xz);&#xa;        blendingWeight /= dot(blendingWeight, vec2(1.0, 1.0));&#xa;&#xa;        // Calculate the texture coordinates:&#xa;        vec4 blendingCoord = fma(blendingOffset, vec4(SMAA_RT_METRICS.xy, -SMAA_RT_METRICS.xy), texcoord.xyxy);&#xa;&#xa;        // We exploit bilinear filtering to mix current pixel with the chosen&#xa;        // neighbor:&#xa;        vec4 color = blendingWeight.x * textureLod(colorTex, blendingCoord.xy, 0.0);&#xa;        color += blendingWeight.y * textureLod(colorTex, blendingCoord.zw, 0.0);&#xa;&#xa;        #if SMAA_REPROJECTION&#xa;        // Antialias velocity for proper reprojection in a later stage:&#xa;        vec2 velocity = blendingWeight.x * SMAA_DECODE_VELOCITY(textureLod(velocityTex, blendingCoord.xy, 0.0));&#xa;        velocity += blendingWeight.y * SMAA_DECODE_VELOCITY(textureLod(velocityTex, blendingCoord.zw, 0.0));&#xa;&#xa;        // Pack velocity into the alpha channel:&#xa;        color.a = sqrt(5.0 * length(velocity));&#xa;        #endif&#xa;&#xa;        return color;&#xa;    }&#xa;}&#xa;&#xa;in vec2 texcoord;&#xa;in vec4 offset;&#xa;&#xa;void main() {&#xa;&#x9;antialiasing = SMAANeighborhoodBlendingPS(texcoord,&#xa;                                  offset,&#xa;                                  imgBuff,&#xa;                                  weightBuff);&#xa;}" name="genericFragBody"/>
   <string val="#version 420&#xa;&#xa;layout(vertices = 4) out;&#xa;uniform sampler2D weightBuff;&#xa;uniform sampler2D imgBuff;&#xa;" name="genericTessCHead"/>
   <string val="void main(void) {&#xa;&#x9;gl_TessLevelOuter[0] = 1;&#xa;&#x9;gl_TessLevelOuter[1] = 1;&#xa;&#x9;gl_TessLevelOuter[2] = 1;&#xa;&#x9;gl_TessLevelOuter[3] = 1;&#xa;&#x9;gl_TessLevelInner[0] = 1;&#xa;&#x9;gl_TessLevelInner[1] = 1;&#xa;&#x9;gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;&#xa;}&#xa;" name="genericTessCBody"/>
   <string val="#version 420&#xa;&#xa;uniform sampler2D weightBuff;&#xa;uniform sampler2D imgBuff;&#xa;" name="genericTessEHead"/>
   <string val="layout(quads,equal_spacing) in;&#xa;&#xa;void main() {&#xa;&#x9;vec4 p1 = mix(gl_in[0].gl_Position,gl_in[1].gl_Position,gl_TessCoord.x);&#xa;&#x9;vec4 p2 = mix(gl_in[3].gl_Position,gl_in[2].gl_Position,gl_TessCoord.x);&#xa;&#x9;gl_Position = mix(p1,p2,gl_TessCoord.y);&#xa;}&#xa;" name="genericTessEBody"/>
   <string val="#version 420&#xa;&#xa;layout(triangles) in;&#xa;uniform sampler2D weightBuff;&#xa;uniform sampler2D imgBuff;&#xa;" name="genericGeomHead"/>
   <string val="layout(triangle_strip, max_vertices = 3) out;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = gl_in[0].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[1].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[2].gl_Position; EmitVertex();&#xa;&#x9;EndPrimitive();&#xa;}" name="genericGeomBody"/>
   <vector2f name="genericTSize">
    <float val="1" name="0"/>
    <float val="1" name="1"/>
   </vector2f>
   <vector2f name="genericTOffset">
    <float val="0" name="0"/>
    <float val="0" name="1"/>
   </vector2f>
   <bool val="0" name="genericNeedMouse"/>
   <bool val="0" name="genericNeedKeyboard"/>
   <uint val="0" name="genericNbWidgets"/>
  </IOData>
  <IOData name="nodeWidget-5">
   <uint val="0" name="nbChildren"/>
  </IOData>
  <vector2f name="nodeInputPos-5-0">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <vector2f name="nodeInputPos-5-1">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
  <vector2f name="nodeOutputPos-5-0">
   <float val="56.32" name="0"/>
   <float val="28.16" name="1"/>
  </vector2f>
 </IOData>
 <IOData name="nodeWidget-0">
  <uint val="6" name="nbChildren"/>
  <IOData name="childWidget-0">
   <uint val="0" name="nbChildren"/>
  </IOData>
  <IOData name="childWidget-1">
   <uint val="1" name="nbChildren"/>
   <IOData name="childWidget-0">
    <bool val="0" name="floatAttribKeyframed"/>
    <float val="0.05" name="floatAttribMinVal"/>
    <float val="0.5" name="floatAttribMaxVal"/>
    <IOData name="floatAttribCurve">
     <float val="0.05" name="currentVal"/>
     <uint val="1" name="nbCurves"/>
     <IOData name="curve-0">
      <int val="0" name="interpType"/>
      <int val="0" name="leftType"/>
      <int val="0" name="rightType"/>
      <IOData name="interpolator">
       <uint val="1" name="nbPoints"/>
       <uint val="0" name="nbTangents"/>
       <vector2f name="controlPoint-0">
        <float val="0" name="0"/>
        <float val="0.05" name="1"/>
       </vector2f>
      </IOData>
     </IOData>
    </IOData>
    <uint val="0" name="nbChildren"/>
   </IOData>
  </IOData>
  <IOData name="childWidget-2">
   <bool val="0" name="keepAspectRatio"/>
   <bool val="0" name="keepSize"/>
  </IOData>
  <IOData name="childWidget-3">
   <uint val="0" name="nbChildren"/>
  </IOData>
  <IOData name="childWidget-4">
   <uint val="1" name="nbChildren"/>
   <IOData name="childWidget-0">
    <bool val="0" name="floatAttribKeyframed"/>
    <float val="1" name="floatAttribMinVal"/>
    <float val="2" name="floatAttribMaxVal"/>
    <IOData name="floatAttribCurve">
     <float val="1" name="currentVal"/>
     <uint val="1" name="nbCurves"/>
     <IOData name="curve-0">
      <int val="0" name="interpType"/>
      <int val="0" name="leftType"/>
      <int val="0" name="rightType"/>
      <IOData name="interpolator">
       <uint val="1" name="nbPoints"/>
       <uint val="0" name="nbTangents"/>
       <vector2f name="controlPoint-0">
        <float val="0" name="0"/>
        <float val="1" name="1"/>
       </vector2f>
      </IOData>
     </IOData>
    </IOData>
    <uint val="0" name="nbChildren"/>
   </IOData>
  </IOData>
  <IOData name="childWidget-5">
   <uint val="0" name="nbChildren"/>
  </IOData>
 </IOData>
 <vector2f name="nodeInputPos-0-0">
  <float val="56.32" name="0"/>
  <float val="28.16" name="1"/>
 </vector2f>
 <vector2f name="nodeOutputPos-0-0">
  <float val="56.32" name="0"/>
  <float val="28.16" name="1"/>
 </vector2f>
</Gratin>
